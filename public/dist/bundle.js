/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@automerge/automerge-wasm/bundler/automerge_wasm.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@automerge/automerge-wasm/bundler/automerge_wasm.js ***!
  \**************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Automerge: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.Automerge),\n/* harmony export */   SyncState: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.SyncState),\n/* harmony export */   TextRepresentation: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.TextRepresentation),\n/* harmony export */   __wbg_String_91fba7ded13ba54c: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_String_91fba7ded13ba54c),\n/* harmony export */   __wbg_apply_5435e78b95a524a6: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_apply_5435e78b95a524a6),\n/* harmony export */   __wbg_assign_b0b6530984f36574: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_assign_b0b6530984f36574),\n/* harmony export */   __wbg_buffer_cf65c07de34b9a08: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_buffer_cf65c07de34b9a08),\n/* harmony export */   __wbg_call_9495de66fdbe016b: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_call_9495de66fdbe016b),\n/* harmony export */   __wbg_call_95d1ea488d03e4e8: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_call_95d1ea488d03e4e8),\n/* harmony export */   __wbg_call_96878afb7a8201ca: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_call_96878afb7a8201ca),\n/* harmony export */   __wbg_concat_040af6c9ba38dd98: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_concat_040af6c9ba38dd98),\n/* harmony export */   __wbg_crypto_70a96de3b6b73dac: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_crypto_70a96de3b6b73dac),\n/* harmony export */   __wbg_defineProperty_4926f24c724d5310: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_defineProperty_4926f24c724d5310),\n/* harmony export */   __wbg_deleteProperty_31090878b92a7c0e: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_deleteProperty_31090878b92a7c0e),\n/* harmony export */   __wbg_done_1ebec03bbd919843: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_done_1ebec03bbd919843),\n/* harmony export */   __wbg_entries_4e1315b774245952: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_entries_4e1315b774245952),\n/* harmony export */   __wbg_error_f851667af71bcfc6: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_error_f851667af71bcfc6),\n/* harmony export */   __wbg_for_9a885d0d6d415e40: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_for_9a885d0d6d415e40),\n/* harmony export */   __wbg_freeze_4dcdbf0b5d9b50f4: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_freeze_4dcdbf0b5d9b50f4),\n/* harmony export */   __wbg_from_67ca20fa722467e6: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_from_67ca20fa722467e6),\n/* harmony export */   __wbg_getRandomValues_3774744e221a22ad: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_getRandomValues_3774744e221a22ad),\n/* harmony export */   __wbg_getTime_7c59072d1651a3cf: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_getTime_7c59072d1651a3cf),\n/* harmony export */   __wbg_get_27fe3dac1c4d0224: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_get_27fe3dac1c4d0224),\n/* harmony export */   __wbg_get_baf4855f9a986186: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_get_baf4855f9a986186),\n/* harmony export */   __wbg_globalThis_87cbb8506fecf3a9: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_globalThis_87cbb8506fecf3a9),\n/* harmony export */   __wbg_global_c85a9259e621f3db: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_global_c85a9259e621f3db),\n/* harmony export */   __wbg_instanceof_ArrayBuffer_a69f02ee4c4f5065: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_instanceof_ArrayBuffer_a69f02ee4c4f5065),\n/* harmony export */   __wbg_instanceof_Date_e353425d719aa266: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_instanceof_Date_e353425d719aa266),\n/* harmony export */   __wbg_instanceof_Object_f5a826c4da0d4a94: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_instanceof_Object_f5a826c4da0d4a94),\n/* harmony export */   __wbg_instanceof_Uint8Array_01cebe79ca606cca: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_instanceof_Uint8Array_01cebe79ca606cca),\n/* harmony export */   __wbg_isArray_39d28997bf6b96b4: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_isArray_39d28997bf6b96b4),\n/* harmony export */   __wbg_iterator_55f114446221aa5a: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_iterator_55f114446221aa5a),\n/* harmony export */   __wbg_keys_60443f4f867207f9: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_keys_60443f4f867207f9),\n/* harmony export */   __wbg_length_27a2afe8ab42b09f: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_length_27a2afe8ab42b09f),\n/* harmony export */   __wbg_length_e498fbc24f9c1d4f: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_length_e498fbc24f9c1d4f),\n/* harmony export */   __wbg_length_ea0846e494e3b16e: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_length_ea0846e494e3b16e),\n/* harmony export */   __wbg_log_7bb108d119bafbc1: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_log_7bb108d119bafbc1),\n/* harmony export */   __wbg_log_d047cf0648d2678e: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_log_d047cf0648d2678e),\n/* harmony export */   __wbg_msCrypto_adbc770ec9eca9c7: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_msCrypto_adbc770ec9eca9c7),\n/* harmony export */   __wbg_new_15d3966e9981a196: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_new_15d3966e9981a196),\n/* harmony export */   __wbg_new_537b7341ce90bb31: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_new_537b7341ce90bb31),\n/* harmony export */   __wbg_new_abda76e883ba8a5f: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_new_abda76e883ba8a5f),\n/* harmony export */   __wbg_new_b525de17f44a8943: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_new_b525de17f44a8943),\n/* harmony export */   __wbg_new_f127e324c1313064: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_new_f127e324c1313064),\n/* harmony export */   __wbg_new_f9876326328f45ed: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_new_f9876326328f45ed),\n/* harmony export */   __wbg_newnoargs_2b8b6bd7753c76ba: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_newnoargs_2b8b6bd7753c76ba),\n/* harmony export */   __wbg_newwithbyteoffsetandlength_9fb2f11355ecadf5: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_newwithbyteoffsetandlength_9fb2f11355ecadf5),\n/* harmony export */   __wbg_newwithlength_b56c882b57805732: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_newwithlength_b56c882b57805732),\n/* harmony export */   __wbg_next_88560ec06a094dea: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_next_88560ec06a094dea),\n/* harmony export */   __wbg_next_b7d530c04fd8b217: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_next_b7d530c04fd8b217),\n/* harmony export */   __wbg_node_6a9d28205ed5b0d8: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_node_6a9d28205ed5b0d8),\n/* harmony export */   __wbg_ownKeys_9efe69be404540aa: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_ownKeys_9efe69be404540aa),\n/* harmony export */   __wbg_process_dd1577445152112e: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_process_dd1577445152112e),\n/* harmony export */   __wbg_push_49c286f04dd3bf59: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_push_49c286f04dd3bf59),\n/* harmony export */   __wbg_randomFillSync_e950366c42764a07: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_randomFillSync_e950366c42764a07),\n/* harmony export */   __wbg_require_f05d779769764e82: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_require_f05d779769764e82),\n/* harmony export */   __wbg_self_e7c1f827057f6584: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_self_e7c1f827057f6584),\n/* harmony export */   __wbg_set_17224bc548dd1d7b: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_set_17224bc548dd1d7b),\n/* harmony export */   __wbg_set_17499e8aa4003ebd: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_set_17499e8aa4003ebd),\n/* harmony export */   __wbg_set_20cbc34131e76824: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_set_20cbc34131e76824),\n/* harmony export */   __wbg_set_6aa458a4ebdb65cb: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_set_6aa458a4ebdb65cb),\n/* harmony export */   __wbg_set_wasm: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_set_wasm),\n/* harmony export */   __wbg_slice_47202b1d012cdc55: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_slice_47202b1d012cdc55),\n/* harmony export */   __wbg_stack_658279fe44541cf6: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_stack_658279fe44541cf6),\n/* harmony export */   __wbg_subarray_7526649b91a252a6: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_subarray_7526649b91a252a6),\n/* harmony export */   __wbg_toString_7a3e0cd68ea2a337: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_toString_7a3e0cd68ea2a337),\n/* harmony export */   __wbg_unshift_06a94bcbcb492eb3: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_unshift_06a94bcbcb492eb3),\n/* harmony export */   __wbg_value_6ac8da5cc5b3efda: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_value_6ac8da5cc5b3efda),\n/* harmony export */   __wbg_values_7444c4c2ccefdc9b: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_values_7444c4c2ccefdc9b),\n/* harmony export */   __wbg_versions_58036bec3add9e6f: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_versions_58036bec3add9e6f),\n/* harmony export */   __wbg_window_a09ec664e14b1b81: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_window_a09ec664e14b1b81),\n/* harmony export */   __wbindgen_bigint_from_i64: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbindgen_bigint_from_i64),\n/* harmony export */   __wbindgen_bigint_from_u64: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbindgen_bigint_from_u64),\n/* harmony export */   __wbindgen_boolean_get: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbindgen_boolean_get),\n/* harmony export */   __wbindgen_debug_string: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbindgen_debug_string),\n/* harmony export */   __wbindgen_error_new: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbindgen_error_new),\n/* harmony export */   __wbindgen_is_function: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbindgen_is_function),\n/* harmony export */   __wbindgen_is_null: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbindgen_is_null),\n/* harmony export */   __wbindgen_is_object: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbindgen_is_object),\n/* harmony export */   __wbindgen_is_string: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbindgen_is_string),\n/* harmony export */   __wbindgen_is_undefined: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbindgen_is_undefined),\n/* harmony export */   __wbindgen_json_serialize: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbindgen_json_serialize),\n/* harmony export */   __wbindgen_jsval_loose_eq: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbindgen_jsval_loose_eq),\n/* harmony export */   __wbindgen_memory: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbindgen_memory),\n/* harmony export */   __wbindgen_number_get: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbindgen_number_get),\n/* harmony export */   __wbindgen_number_new: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbindgen_number_new),\n/* harmony export */   __wbindgen_object_clone_ref: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbindgen_object_clone_ref),\n/* harmony export */   __wbindgen_object_drop_ref: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbindgen_object_drop_ref),\n/* harmony export */   __wbindgen_string_get: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbindgen_string_get),\n/* harmony export */   __wbindgen_string_new: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbindgen_string_new),\n/* harmony export */   __wbindgen_throw: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbindgen_throw),\n/* harmony export */   create: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.create),\n/* harmony export */   decodeChange: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.decodeChange),\n/* harmony export */   decodeSyncMessage: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.decodeSyncMessage),\n/* harmony export */   decodeSyncState: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.decodeSyncState),\n/* harmony export */   encodeChange: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.encodeChange),\n/* harmony export */   encodeSyncMessage: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.encodeSyncMessage),\n/* harmony export */   encodeSyncState: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.encodeSyncState),\n/* harmony export */   exportSyncState: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.exportSyncState),\n/* harmony export */   importSyncState: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.importSyncState),\n/* harmony export */   initSyncState: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.initSyncState),\n/* harmony export */   load: () => (/* reexport safe */ _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.load)\n/* harmony export */ });\n/* harmony import */ var _automerge_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./automerge_wasm_bg.wasm */ \"./node_modules/@automerge/automerge-wasm/bundler/automerge_wasm_bg.wasm\");\n/* harmony import */ var _automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./automerge_wasm_bg.js */ \"./node_modules/@automerge/automerge-wasm/bundler/automerge_wasm_bg.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_automerge_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__]);\n_automerge_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n(0,_automerge_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__.__wbg_set_wasm)(_automerge_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__);\n\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://experiments/./node_modules/@automerge/automerge-wasm/bundler/automerge_wasm.js?");

/***/ }),

/***/ "./node_modules/@automerge/automerge-wasm/bundler/automerge_wasm_bg.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@automerge/automerge-wasm/bundler/automerge_wasm_bg.js ***!
  \*****************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Automerge: () => (/* binding */ Automerge),\n/* harmony export */   SyncState: () => (/* binding */ SyncState),\n/* harmony export */   TextRepresentation: () => (/* binding */ TextRepresentation),\n/* harmony export */   __wbg_String_91fba7ded13ba54c: () => (/* binding */ __wbg_String_91fba7ded13ba54c),\n/* harmony export */   __wbg_apply_5435e78b95a524a6: () => (/* binding */ __wbg_apply_5435e78b95a524a6),\n/* harmony export */   __wbg_assign_b0b6530984f36574: () => (/* binding */ __wbg_assign_b0b6530984f36574),\n/* harmony export */   __wbg_buffer_cf65c07de34b9a08: () => (/* binding */ __wbg_buffer_cf65c07de34b9a08),\n/* harmony export */   __wbg_call_9495de66fdbe016b: () => (/* binding */ __wbg_call_9495de66fdbe016b),\n/* harmony export */   __wbg_call_95d1ea488d03e4e8: () => (/* binding */ __wbg_call_95d1ea488d03e4e8),\n/* harmony export */   __wbg_call_96878afb7a8201ca: () => (/* binding */ __wbg_call_96878afb7a8201ca),\n/* harmony export */   __wbg_concat_040af6c9ba38dd98: () => (/* binding */ __wbg_concat_040af6c9ba38dd98),\n/* harmony export */   __wbg_crypto_70a96de3b6b73dac: () => (/* binding */ __wbg_crypto_70a96de3b6b73dac),\n/* harmony export */   __wbg_defineProperty_4926f24c724d5310: () => (/* binding */ __wbg_defineProperty_4926f24c724d5310),\n/* harmony export */   __wbg_deleteProperty_31090878b92a7c0e: () => (/* binding */ __wbg_deleteProperty_31090878b92a7c0e),\n/* harmony export */   __wbg_done_1ebec03bbd919843: () => (/* binding */ __wbg_done_1ebec03bbd919843),\n/* harmony export */   __wbg_entries_4e1315b774245952: () => (/* binding */ __wbg_entries_4e1315b774245952),\n/* harmony export */   __wbg_error_f851667af71bcfc6: () => (/* binding */ __wbg_error_f851667af71bcfc6),\n/* harmony export */   __wbg_for_9a885d0d6d415e40: () => (/* binding */ __wbg_for_9a885d0d6d415e40),\n/* harmony export */   __wbg_freeze_4dcdbf0b5d9b50f4: () => (/* binding */ __wbg_freeze_4dcdbf0b5d9b50f4),\n/* harmony export */   __wbg_from_67ca20fa722467e6: () => (/* binding */ __wbg_from_67ca20fa722467e6),\n/* harmony export */   __wbg_getRandomValues_3774744e221a22ad: () => (/* binding */ __wbg_getRandomValues_3774744e221a22ad),\n/* harmony export */   __wbg_getTime_7c59072d1651a3cf: () => (/* binding */ __wbg_getTime_7c59072d1651a3cf),\n/* harmony export */   __wbg_get_27fe3dac1c4d0224: () => (/* binding */ __wbg_get_27fe3dac1c4d0224),\n/* harmony export */   __wbg_get_baf4855f9a986186: () => (/* binding */ __wbg_get_baf4855f9a986186),\n/* harmony export */   __wbg_globalThis_87cbb8506fecf3a9: () => (/* binding */ __wbg_globalThis_87cbb8506fecf3a9),\n/* harmony export */   __wbg_global_c85a9259e621f3db: () => (/* binding */ __wbg_global_c85a9259e621f3db),\n/* harmony export */   __wbg_instanceof_ArrayBuffer_a69f02ee4c4f5065: () => (/* binding */ __wbg_instanceof_ArrayBuffer_a69f02ee4c4f5065),\n/* harmony export */   __wbg_instanceof_Date_e353425d719aa266: () => (/* binding */ __wbg_instanceof_Date_e353425d719aa266),\n/* harmony export */   __wbg_instanceof_Object_f5a826c4da0d4a94: () => (/* binding */ __wbg_instanceof_Object_f5a826c4da0d4a94),\n/* harmony export */   __wbg_instanceof_Uint8Array_01cebe79ca606cca: () => (/* binding */ __wbg_instanceof_Uint8Array_01cebe79ca606cca),\n/* harmony export */   __wbg_isArray_39d28997bf6b96b4: () => (/* binding */ __wbg_isArray_39d28997bf6b96b4),\n/* harmony export */   __wbg_iterator_55f114446221aa5a: () => (/* binding */ __wbg_iterator_55f114446221aa5a),\n/* harmony export */   __wbg_keys_60443f4f867207f9: () => (/* binding */ __wbg_keys_60443f4f867207f9),\n/* harmony export */   __wbg_length_27a2afe8ab42b09f: () => (/* binding */ __wbg_length_27a2afe8ab42b09f),\n/* harmony export */   __wbg_length_e498fbc24f9c1d4f: () => (/* binding */ __wbg_length_e498fbc24f9c1d4f),\n/* harmony export */   __wbg_length_ea0846e494e3b16e: () => (/* binding */ __wbg_length_ea0846e494e3b16e),\n/* harmony export */   __wbg_log_7bb108d119bafbc1: () => (/* binding */ __wbg_log_7bb108d119bafbc1),\n/* harmony export */   __wbg_log_d047cf0648d2678e: () => (/* binding */ __wbg_log_d047cf0648d2678e),\n/* harmony export */   __wbg_msCrypto_adbc770ec9eca9c7: () => (/* binding */ __wbg_msCrypto_adbc770ec9eca9c7),\n/* harmony export */   __wbg_new_15d3966e9981a196: () => (/* binding */ __wbg_new_15d3966e9981a196),\n/* harmony export */   __wbg_new_537b7341ce90bb31: () => (/* binding */ __wbg_new_537b7341ce90bb31),\n/* harmony export */   __wbg_new_abda76e883ba8a5f: () => (/* binding */ __wbg_new_abda76e883ba8a5f),\n/* harmony export */   __wbg_new_b525de17f44a8943: () => (/* binding */ __wbg_new_b525de17f44a8943),\n/* harmony export */   __wbg_new_f127e324c1313064: () => (/* binding */ __wbg_new_f127e324c1313064),\n/* harmony export */   __wbg_new_f9876326328f45ed: () => (/* binding */ __wbg_new_f9876326328f45ed),\n/* harmony export */   __wbg_newnoargs_2b8b6bd7753c76ba: () => (/* binding */ __wbg_newnoargs_2b8b6bd7753c76ba),\n/* harmony export */   __wbg_newwithbyteoffsetandlength_9fb2f11355ecadf5: () => (/* binding */ __wbg_newwithbyteoffsetandlength_9fb2f11355ecadf5),\n/* harmony export */   __wbg_newwithlength_b56c882b57805732: () => (/* binding */ __wbg_newwithlength_b56c882b57805732),\n/* harmony export */   __wbg_next_88560ec06a094dea: () => (/* binding */ __wbg_next_88560ec06a094dea),\n/* harmony export */   __wbg_next_b7d530c04fd8b217: () => (/* binding */ __wbg_next_b7d530c04fd8b217),\n/* harmony export */   __wbg_node_6a9d28205ed5b0d8: () => (/* binding */ __wbg_node_6a9d28205ed5b0d8),\n/* harmony export */   __wbg_ownKeys_9efe69be404540aa: () => (/* binding */ __wbg_ownKeys_9efe69be404540aa),\n/* harmony export */   __wbg_process_dd1577445152112e: () => (/* binding */ __wbg_process_dd1577445152112e),\n/* harmony export */   __wbg_push_49c286f04dd3bf59: () => (/* binding */ __wbg_push_49c286f04dd3bf59),\n/* harmony export */   __wbg_randomFillSync_e950366c42764a07: () => (/* binding */ __wbg_randomFillSync_e950366c42764a07),\n/* harmony export */   __wbg_require_f05d779769764e82: () => (/* binding */ __wbg_require_f05d779769764e82),\n/* harmony export */   __wbg_self_e7c1f827057f6584: () => (/* binding */ __wbg_self_e7c1f827057f6584),\n/* harmony export */   __wbg_set_17224bc548dd1d7b: () => (/* binding */ __wbg_set_17224bc548dd1d7b),\n/* harmony export */   __wbg_set_17499e8aa4003ebd: () => (/* binding */ __wbg_set_17499e8aa4003ebd),\n/* harmony export */   __wbg_set_20cbc34131e76824: () => (/* binding */ __wbg_set_20cbc34131e76824),\n/* harmony export */   __wbg_set_6aa458a4ebdb65cb: () => (/* binding */ __wbg_set_6aa458a4ebdb65cb),\n/* harmony export */   __wbg_set_wasm: () => (/* binding */ __wbg_set_wasm),\n/* harmony export */   __wbg_slice_47202b1d012cdc55: () => (/* binding */ __wbg_slice_47202b1d012cdc55),\n/* harmony export */   __wbg_stack_658279fe44541cf6: () => (/* binding */ __wbg_stack_658279fe44541cf6),\n/* harmony export */   __wbg_subarray_7526649b91a252a6: () => (/* binding */ __wbg_subarray_7526649b91a252a6),\n/* harmony export */   __wbg_toString_7a3e0cd68ea2a337: () => (/* binding */ __wbg_toString_7a3e0cd68ea2a337),\n/* harmony export */   __wbg_unshift_06a94bcbcb492eb3: () => (/* binding */ __wbg_unshift_06a94bcbcb492eb3),\n/* harmony export */   __wbg_value_6ac8da5cc5b3efda: () => (/* binding */ __wbg_value_6ac8da5cc5b3efda),\n/* harmony export */   __wbg_values_7444c4c2ccefdc9b: () => (/* binding */ __wbg_values_7444c4c2ccefdc9b),\n/* harmony export */   __wbg_versions_58036bec3add9e6f: () => (/* binding */ __wbg_versions_58036bec3add9e6f),\n/* harmony export */   __wbg_window_a09ec664e14b1b81: () => (/* binding */ __wbg_window_a09ec664e14b1b81),\n/* harmony export */   __wbindgen_bigint_from_i64: () => (/* binding */ __wbindgen_bigint_from_i64),\n/* harmony export */   __wbindgen_bigint_from_u64: () => (/* binding */ __wbindgen_bigint_from_u64),\n/* harmony export */   __wbindgen_boolean_get: () => (/* binding */ __wbindgen_boolean_get),\n/* harmony export */   __wbindgen_debug_string: () => (/* binding */ __wbindgen_debug_string),\n/* harmony export */   __wbindgen_error_new: () => (/* binding */ __wbindgen_error_new),\n/* harmony export */   __wbindgen_is_function: () => (/* binding */ __wbindgen_is_function),\n/* harmony export */   __wbindgen_is_null: () => (/* binding */ __wbindgen_is_null),\n/* harmony export */   __wbindgen_is_object: () => (/* binding */ __wbindgen_is_object),\n/* harmony export */   __wbindgen_is_string: () => (/* binding */ __wbindgen_is_string),\n/* harmony export */   __wbindgen_is_undefined: () => (/* binding */ __wbindgen_is_undefined),\n/* harmony export */   __wbindgen_json_serialize: () => (/* binding */ __wbindgen_json_serialize),\n/* harmony export */   __wbindgen_jsval_loose_eq: () => (/* binding */ __wbindgen_jsval_loose_eq),\n/* harmony export */   __wbindgen_memory: () => (/* binding */ __wbindgen_memory),\n/* harmony export */   __wbindgen_number_get: () => (/* binding */ __wbindgen_number_get),\n/* harmony export */   __wbindgen_number_new: () => (/* binding */ __wbindgen_number_new),\n/* harmony export */   __wbindgen_object_clone_ref: () => (/* binding */ __wbindgen_object_clone_ref),\n/* harmony export */   __wbindgen_object_drop_ref: () => (/* binding */ __wbindgen_object_drop_ref),\n/* harmony export */   __wbindgen_string_get: () => (/* binding */ __wbindgen_string_get),\n/* harmony export */   __wbindgen_string_new: () => (/* binding */ __wbindgen_string_new),\n/* harmony export */   __wbindgen_throw: () => (/* binding */ __wbindgen_throw),\n/* harmony export */   create: () => (/* binding */ create),\n/* harmony export */   decodeChange: () => (/* binding */ decodeChange),\n/* harmony export */   decodeSyncMessage: () => (/* binding */ decodeSyncMessage),\n/* harmony export */   decodeSyncState: () => (/* binding */ decodeSyncState),\n/* harmony export */   encodeChange: () => (/* binding */ encodeChange),\n/* harmony export */   encodeSyncMessage: () => (/* binding */ encodeSyncMessage),\n/* harmony export */   encodeSyncState: () => (/* binding */ encodeSyncState),\n/* harmony export */   exportSyncState: () => (/* binding */ exportSyncState),\n/* harmony export */   importSyncState: () => (/* binding */ importSyncState),\n/* harmony export */   initSyncState: () => (/* binding */ initSyncState),\n/* harmony export */   load: () => (/* binding */ load)\n/* harmony export */ });\n/* module decorator */ module = __webpack_require__.hmd(module);\nlet wasm;\nfunction __wbg_set_wasm(val) {\n    wasm = val;\n}\n\n\nconst heap = new Array(128).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nfunction getObject(idx) { return heap[idx]; }\n\nlet heap_next = heap.length;\n\nfunction dropObject(idx) {\n    if (idx < 132) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nconst lTextDecoder = typeof TextDecoder === 'undefined' ? (0, module.require)('util').TextDecoder : TextDecoder;\n\nlet cachedTextDecoder = new lTextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nlet cachedUint8Memory0 = null;\n\nfunction getUint8Memory0() {\n    if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {\n        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nconst lTextEncoder = typeof TextEncoder === 'undefined' ? (0, module.require)('util').TextEncoder : TextEncoder;\n\nlet cachedTextEncoder = new lTextEncoder('utf-8');\n\nconst encodeString = (typeof cachedTextEncoder.encodeInto === 'function'\n    ? function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n}\n    : function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n});\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length);\n        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len);\n\n    const mem = getUint8Memory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3);\n        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n\n        offset += ret.written;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nlet cachedInt32Memory0 = null;\n\nfunction getInt32Memory0() {\n    if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {\n        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachedInt32Memory0;\n}\n\nlet cachedFloat64Memory0 = null;\n\nfunction getFloat64Memory0() {\n    if (cachedFloat64Memory0 === null || cachedFloat64Memory0.byteLength === 0) {\n        cachedFloat64Memory0 = new Float64Array(wasm.memory.buffer);\n    }\n    return cachedFloat64Memory0;\n}\n\nfunction debugString(val) {\n    // primitive types\n    const type = typeof val;\n    if (type == 'number' || type == 'boolean' || val == null) {\n        return  `${val}`;\n    }\n    if (type == 'string') {\n        return `\"${val}\"`;\n    }\n    if (type == 'symbol') {\n        const description = val.description;\n        if (description == null) {\n            return 'Symbol';\n        } else {\n            return `Symbol(${description})`;\n        }\n    }\n    if (type == 'function') {\n        const name = val.name;\n        if (typeof name == 'string' && name.length > 0) {\n            return `Function(${name})`;\n        } else {\n            return 'Function';\n        }\n    }\n    // objects\n    if (Array.isArray(val)) {\n        const length = val.length;\n        let debug = '[';\n        if (length > 0) {\n            debug += debugString(val[0]);\n        }\n        for(let i = 1; i < length; i++) {\n            debug += ', ' + debugString(val[i]);\n        }\n        debug += ']';\n        return debug;\n    }\n    // Test for built-in\n    const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val));\n    let className;\n    if (builtInMatches.length > 1) {\n        className = builtInMatches[1];\n    } else {\n        // Failed to match the standard '[object ClassName]'\n        return toString.call(val);\n    }\n    if (className == 'Object') {\n        // we're a user defined class or Object\n        // JSON.stringify avoids problems with cycles, and is generally much\n        // easier than looping through ownProperties of `val`.\n        try {\n            return 'Object(' + JSON.stringify(val) + ')';\n        } catch (_) {\n            return 'Object';\n        }\n    }\n    // errors\n    if (val instanceof Error) {\n        return `${val.name}: ${val.message}\\n${val.stack}`;\n    }\n    // TODO we could test for more things here, like `Set`s and `Map`s.\n    return className;\n}\n\nfunction _assertClass(instance, klass) {\n    if (!(instance instanceof klass)) {\n        throw new Error(`expected instance of ${klass.name}`);\n    }\n    return instance.ptr;\n}\n/**\n* @param {boolean} text_v2\n* @param {string | undefined} actor\n* @returns {Automerge}\n*/\nfunction create(text_v2, actor) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        var ptr0 = isLikeNone(actor) ? 0 : passStringToWasm0(actor, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.create(retptr, text_v2, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return Automerge.__wrap(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {Uint8Array} data\n* @param {boolean} text_v2\n* @param {string | undefined} actor\n* @returns {Automerge}\n*/\nfunction load(data, text_v2, actor) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        var ptr0 = isLikeNone(actor) ? 0 : passStringToWasm0(actor, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.load(retptr, addHeapObject(data), text_v2, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return Automerge.__wrap(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {any} change\n* @returns {Uint8Array}\n*/\nfunction encodeChange(change) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.encodeChange(retptr, addHeapObject(change));\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {Uint8Array} change\n* @returns {any}\n*/\nfunction decodeChange(change) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.decodeChange(retptr, addHeapObject(change));\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @returns {SyncState}\n*/\nfunction initSyncState() {\n    const ret = wasm.initSyncState();\n    return SyncState.__wrap(ret);\n}\n\n/**\n* @param {any} state\n* @returns {SyncState}\n*/\nfunction importSyncState(state) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.importSyncState(retptr, addHeapObject(state));\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return SyncState.__wrap(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {SyncState} state\n* @returns {any}\n*/\nfunction exportSyncState(state) {\n    _assertClass(state, SyncState);\n    const ret = wasm.exportSyncState(state.ptr);\n    return takeObject(ret);\n}\n\n/**\n* @param {any} message\n* @returns {Uint8Array}\n*/\nfunction encodeSyncMessage(message) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.encodeSyncMessage(retptr, addHeapObject(message));\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {Uint8Array} msg\n* @returns {any}\n*/\nfunction decodeSyncMessage(msg) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.decodeSyncMessage(retptr, addHeapObject(msg));\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {SyncState} state\n* @returns {Uint8Array}\n*/\nfunction encodeSyncState(state) {\n    _assertClass(state, SyncState);\n    const ret = wasm.encodeSyncState(state.ptr);\n    return takeObject(ret);\n}\n\n/**\n* @param {Uint8Array} data\n* @returns {SyncState}\n*/\nfunction decodeSyncState(data) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.decodeSyncState(retptr, addHeapObject(data));\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return SyncState.__wrap(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\nfunction handleError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        wasm.__wbindgen_exn_store(addHeapObject(e));\n    }\n}\n/**\n* How text is represented in materialized objects on the JS side\n*/\nconst TextRepresentation = Object.freeze({\n/**\n* As an array of characters and objects\n*/\nArray:0,\"0\":\"Array\",\n/**\n* As a single JS string\n*/\nString:1,\"1\":\"String\", });\n\nconst AutomergeFinalization = new FinalizationRegistry(ptr => wasm.__wbg_automerge_free(ptr));\n/**\n*/\nclass Automerge {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Automerge.prototype);\n        obj.ptr = ptr;\n        AutomergeFinalization.register(obj, obj.ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        AutomergeFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_automerge_free(ptr);\n    }\n    /**\n    * @param {string | undefined} actor\n    * @param {number} text_rep\n    * @returns {Automerge}\n    */\n    static new(actor, text_rep) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = isLikeNone(actor) ? 0 : passStringToWasm0(actor, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.automerge_new(retptr, ptr0, len0, text_rep);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Automerge.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string | undefined} actor\n    * @returns {Automerge}\n    */\n    clone(actor) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = isLikeNone(actor) ? 0 : passStringToWasm0(actor, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.automerge_clone(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Automerge.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string | undefined} actor\n    * @param {any} heads\n    * @returns {Automerge}\n    */\n    fork(actor, heads) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = isLikeNone(actor) ? 0 : passStringToWasm0(actor, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.automerge_fork(retptr, this.ptr, ptr0, len0, addHeapObject(heads));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Automerge.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    pendingOps() {\n        const ret = wasm.automerge_pendingOps(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string | undefined} message\n    * @param {number | undefined} time\n    * @returns {any}\n    */\n    commit(message, time) {\n        var ptr0 = isLikeNone(message) ? 0 : passStringToWasm0(message, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        const ret = wasm.automerge_commit(this.ptr, ptr0, len0, !isLikeNone(time), isLikeNone(time) ? 0 : time);\n        return takeObject(ret);\n    }\n    /**\n    * @param {Automerge} other\n    * @returns {Array<any>}\n    */\n    merge(other) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(other, Automerge);\n            wasm.automerge_merge(retptr, this.ptr, other.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {number}\n    */\n    rollback() {\n        const ret = wasm.automerge_rollback(this.ptr);\n        return ret;\n    }\n    /**\n    * @param {any} obj\n    * @param {Array<any> | undefined} heads\n    * @returns {Array<any>}\n    */\n    keys(obj, heads) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_keys(retptr, this.ptr, addHeapObject(obj), isLikeNone(heads) ? 0 : addHeapObject(heads));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {Array<any> | undefined} heads\n    * @returns {string}\n    */\n    text(obj, heads) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_text(retptr, this.ptr, addHeapObject(obj), isLikeNone(heads) ? 0 : addHeapObject(heads));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr0 = r0;\n            var len0 = r1;\n            if (r3) {\n                ptr0 = 0; len0 = 0;\n                throw takeObject(r2);\n            }\n            return getStringFromWasm0(ptr0, len0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(ptr0, len0);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {number} start\n    * @param {number} delete_count\n    * @param {any} text\n    */\n    splice(obj, start, delete_count, text) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_splice(retptr, this.ptr, addHeapObject(obj), start, delete_count, addHeapObject(text));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {any} value\n    * @param {any} datatype\n    */\n    push(obj, value, datatype) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_push(retptr, this.ptr, addHeapObject(obj), addHeapObject(value), addHeapObject(datatype));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {any} value\n    * @returns {string | undefined}\n    */\n    pushObject(obj, value) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_pushObject(retptr, this.ptr, addHeapObject(obj), addHeapObject(value));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            let v0;\n            if (r0 !== 0) {\n                v0 = getStringFromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {number} index\n    * @param {any} value\n    * @param {any} datatype\n    */\n    insert(obj, index, value, datatype) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_insert(retptr, this.ptr, addHeapObject(obj), index, addHeapObject(value), addHeapObject(datatype));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {number} index\n    * @param {any} value\n    * @returns {string | undefined}\n    */\n    insertObject(obj, index, value) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_insertObject(retptr, this.ptr, addHeapObject(obj), index, addHeapObject(value));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            let v0;\n            if (r0 !== 0) {\n                v0 = getStringFromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {any} prop\n    * @param {any} value\n    * @param {any} datatype\n    */\n    put(obj, prop, value, datatype) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_put(retptr, this.ptr, addHeapObject(obj), addHeapObject(prop), addHeapObject(value), addHeapObject(datatype));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {any} prop\n    * @param {any} value\n    * @returns {any}\n    */\n    putObject(obj, prop, value) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_putObject(retptr, this.ptr, addHeapObject(obj), addHeapObject(prop), addHeapObject(value));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {any} prop\n    * @param {any} value\n    */\n    increment(obj, prop, value) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_increment(retptr, this.ptr, addHeapObject(obj), addHeapObject(prop), addHeapObject(value));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {any} prop\n    * @param {Array<any> | undefined} heads\n    * @returns {any}\n    */\n    get(obj, prop, heads) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_get(retptr, this.ptr, addHeapObject(obj), addHeapObject(prop), isLikeNone(heads) ? 0 : addHeapObject(heads));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {any} prop\n    * @param {Array<any> | undefined} heads\n    * @returns {any}\n    */\n    getWithType(obj, prop, heads) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_getWithType(retptr, this.ptr, addHeapObject(obj), addHeapObject(prop), isLikeNone(heads) ? 0 : addHeapObject(heads));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {any} arg\n    * @param {Array<any> | undefined} heads\n    * @returns {Array<any>}\n    */\n    getAll(obj, arg, heads) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_getAll(retptr, this.ptr, addHeapObject(obj), addHeapObject(arg), isLikeNone(heads) ? 0 : addHeapObject(heads));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} enable\n    * @returns {any}\n    */\n    enableFreeze(enable) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_enableFreeze(retptr, this.ptr, addHeapObject(enable));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} enable\n    * @returns {any}\n    */\n    enablePatches(enable) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_enablePatches(retptr, this.ptr, addHeapObject(enable));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} datatype\n    * @param {any} _function\n    */\n    registerDatatype(datatype, _function) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_registerDatatype(retptr, this.ptr, addHeapObject(datatype), addHeapObject(_function));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} object\n    * @param {any} meta\n    * @param {any} callback\n    * @returns {any}\n    */\n    applyPatches(object, meta, callback) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_applyPatches(retptr, this.ptr, addHeapObject(object), addHeapObject(meta), addHeapObject(callback));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Array<any>}\n    */\n    popPatches() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_popPatches(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {Array<any> | undefined} heads\n    * @returns {number}\n    */\n    length(obj, heads) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_length(retptr, this.ptr, addHeapObject(obj), isLikeNone(heads) ? 0 : addHeapObject(heads));\n            var r0 = getFloat64Memory0()[retptr / 8 + 0];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            return r0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {any} prop\n    */\n    delete(obj, prop) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_delete(retptr, this.ptr, addHeapObject(obj), addHeapObject(prop));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    save() {\n        const ret = wasm.automerge_save(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    saveIncremental() {\n        const ret = wasm.automerge_saveIncremental(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    saveNoCompress() {\n        const ret = wasm.automerge_saveNoCompress(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    saveAndVerify() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_saveAndVerify(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} data\n    * @returns {number}\n    */\n    loadIncremental(data) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_loadIncremental(retptr, this.ptr, addHeapObject(data));\n            var r0 = getFloat64Memory0()[retptr / 8 + 0];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            return r0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} changes\n    */\n    applyChanges(changes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_applyChanges(retptr, this.ptr, addHeapObject(changes));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} have_deps\n    * @returns {Array<any>}\n    */\n    getChanges(have_deps) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_getChanges(retptr, this.ptr, addHeapObject(have_deps));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} hash\n    * @returns {any}\n    */\n    getChangeByHash(hash) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_getChangeByHash(retptr, this.ptr, addHeapObject(hash));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Automerge} other\n    * @returns {Array<any>}\n    */\n    getChangesAdded(other) {\n        _assertClass(other, Automerge);\n        const ret = wasm.automerge_getChangesAdded(this.ptr, other.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @returns {Array<any>}\n    */\n    getHeads() {\n        const ret = wasm.automerge_getHeads(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    getActorId() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_getActorId(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    getLastLocalChange() {\n        const ret = wasm.automerge_getLastLocalChange(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    */\n    dump() {\n        wasm.automerge_dump(this.ptr);\n    }\n    /**\n    * @param {Array<any> | undefined} heads\n    * @returns {Array<any>}\n    */\n    getMissingDeps(heads) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_getMissingDeps(retptr, this.ptr, isLikeNone(heads) ? 0 : addHeapObject(heads));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {SyncState} state\n    * @param {Uint8Array} message\n    */\n    receiveSyncMessage(state, message) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(state, SyncState);\n            wasm.automerge_receiveSyncMessage(retptr, this.ptr, state.ptr, addHeapObject(message));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {SyncState} state\n    * @returns {any}\n    */\n    generateSyncMessage(state) {\n        _assertClass(state, SyncState);\n        const ret = wasm.automerge_generateSyncMessage(this.ptr, state.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {any} meta\n    * @returns {any}\n    */\n    toJS(meta) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_toJS(retptr, this.ptr, addHeapObject(meta));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {Array<any> | undefined} heads\n    * @param {any} meta\n    * @returns {any}\n    */\n    materialize(obj, heads, meta) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_materialize(retptr, this.ptr, addHeapObject(obj), isLikeNone(heads) ? 0 : addHeapObject(heads), addHeapObject(meta));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string | undefined} message\n    * @param {number | undefined} time\n    * @returns {any}\n    */\n    emptyChange(message, time) {\n        var ptr0 = isLikeNone(message) ? 0 : passStringToWasm0(message, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        const ret = wasm.automerge_emptyChange(this.ptr, ptr0, len0, !isLikeNone(time), isLikeNone(time) ? 0 : time);\n        return takeObject(ret);\n    }\n    /**\n    * @param {any} obj\n    * @param {any} range\n    * @param {any} name\n    * @param {any} value\n    * @param {any} datatype\n    */\n    mark(obj, range, name, value, datatype) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_mark(retptr, this.ptr, addHeapObject(obj), addHeapObject(range), addHeapObject(name), addHeapObject(value), addHeapObject(datatype));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {any} range\n    * @param {any} name\n    */\n    unmark(obj, range, name) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_unmark(retptr, this.ptr, addHeapObject(obj), addHeapObject(range), addHeapObject(name));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {Array<any> | undefined} heads\n    * @returns {any}\n    */\n    marks(obj, heads) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_marks(retptr, this.ptr, addHeapObject(obj), isLikeNone(heads) ? 0 : addHeapObject(heads));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n\nconst SyncStateFinalization = new FinalizationRegistry(ptr => wasm.__wbg_syncstate_free(ptr));\n/**\n*/\nclass SyncState {\n\n    static __wrap(ptr) {\n        const obj = Object.create(SyncState.prototype);\n        obj.ptr = ptr;\n        SyncStateFinalization.register(obj, obj.ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        SyncStateFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_syncstate_free(ptr);\n    }\n    /**\n    * @returns {any}\n    */\n    get sharedHeads() {\n        const ret = wasm.syncstate_sharedHeads(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @returns {any}\n    */\n    get lastSentHeads() {\n        const ret = wasm.syncstate_lastSentHeads(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {any} heads\n    */\n    set lastSentHeads(heads) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.syncstate_set_lastSentHeads(retptr, this.ptr, addHeapObject(heads));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} hashes\n    */\n    set sentHashes(hashes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.syncstate_set_sentHashes(retptr, this.ptr, addHeapObject(hashes));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {SyncState}\n    */\n    clone() {\n        const ret = wasm.syncstate_clone(this.ptr);\n        return SyncState.__wrap(ret);\n    }\n}\n\nfunction __wbindgen_object_drop_ref(arg0) {\n    takeObject(arg0);\n};\n\nfunction __wbindgen_string_new(arg0, arg1) {\n    const ret = getStringFromWasm0(arg0, arg1);\n    return addHeapObject(ret);\n};\n\nfunction __wbindgen_is_null(arg0) {\n    const ret = getObject(arg0) === null;\n    return ret;\n};\n\nfunction __wbindgen_error_new(arg0, arg1) {\n    const ret = new Error(getStringFromWasm0(arg0, arg1));\n    return addHeapObject(ret);\n};\n\nfunction __wbindgen_string_get(arg0, arg1) {\n    const obj = getObject(arg1);\n    const ret = typeof(obj) === 'string' ? obj : undefined;\n    var ptr0 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len0 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len0;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n};\n\nfunction __wbindgen_object_clone_ref(arg0) {\n    const ret = getObject(arg0);\n    return addHeapObject(ret);\n};\n\nfunction __wbindgen_number_get(arg0, arg1) {\n    const obj = getObject(arg1);\n    const ret = typeof(obj) === 'number' ? obj : undefined;\n    getFloat64Memory0()[arg0 / 8 + 1] = isLikeNone(ret) ? 0 : ret;\n    getInt32Memory0()[arg0 / 4 + 0] = !isLikeNone(ret);\n};\n\nfunction __wbindgen_is_undefined(arg0) {\n    const ret = getObject(arg0) === undefined;\n    return ret;\n};\n\nfunction __wbindgen_boolean_get(arg0) {\n    const v = getObject(arg0);\n    const ret = typeof(v) === 'boolean' ? (v ? 1 : 0) : 2;\n    return ret;\n};\n\nfunction __wbindgen_number_new(arg0) {\n    const ret = arg0;\n    return addHeapObject(ret);\n};\n\nfunction __wbindgen_is_function(arg0) {\n    const ret = typeof(getObject(arg0)) === 'function';\n    return ret;\n};\n\nfunction __wbindgen_is_string(arg0) {\n    const ret = typeof(getObject(arg0)) === 'string';\n    return ret;\n};\n\nfunction __wbindgen_json_serialize(arg0, arg1) {\n    const obj = getObject(arg1);\n    const ret = JSON.stringify(obj === undefined ? null : obj);\n    const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len0 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len0;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n};\n\nfunction __wbg_new_abda76e883ba8a5f() {\n    const ret = new Error();\n    return addHeapObject(ret);\n};\n\nfunction __wbg_stack_658279fe44541cf6(arg0, arg1) {\n    const ret = getObject(arg1).stack;\n    const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len0 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len0;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n};\n\nfunction __wbg_error_f851667af71bcfc6(arg0, arg1) {\n    try {\n        console.error(getStringFromWasm0(arg0, arg1));\n    } finally {\n        wasm.__wbindgen_free(arg0, arg1);\n    }\n};\n\nfunction __wbindgen_is_object(arg0) {\n    const val = getObject(arg0);\n    const ret = typeof(val) === 'object' && val !== null;\n    return ret;\n};\n\nfunction __wbindgen_jsval_loose_eq(arg0, arg1) {\n    const ret = getObject(arg0) == getObject(arg1);\n    return ret;\n};\n\nfunction __wbg_String_91fba7ded13ba54c(arg0, arg1) {\n    const ret = String(getObject(arg1));\n    const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len0 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len0;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n};\n\nfunction __wbindgen_bigint_from_i64(arg0) {\n    const ret = arg0;\n    return addHeapObject(ret);\n};\n\nfunction __wbindgen_bigint_from_u64(arg0) {\n    const ret = BigInt.asUintN(64, arg0);\n    return addHeapObject(ret);\n};\n\nfunction __wbg_set_20cbc34131e76824(arg0, arg1, arg2) {\n    getObject(arg0)[takeObject(arg1)] = takeObject(arg2);\n};\n\nfunction __wbg_getRandomValues_3774744e221a22ad() { return handleError(function (arg0, arg1) {\n    getObject(arg0).getRandomValues(getObject(arg1));\n}, arguments) };\n\nfunction __wbg_randomFillSync_e950366c42764a07() { return handleError(function (arg0, arg1) {\n    getObject(arg0).randomFillSync(takeObject(arg1));\n}, arguments) };\n\nfunction __wbg_crypto_70a96de3b6b73dac(arg0) {\n    const ret = getObject(arg0).crypto;\n    return addHeapObject(ret);\n};\n\nfunction __wbg_process_dd1577445152112e(arg0) {\n    const ret = getObject(arg0).process;\n    return addHeapObject(ret);\n};\n\nfunction __wbg_versions_58036bec3add9e6f(arg0) {\n    const ret = getObject(arg0).versions;\n    return addHeapObject(ret);\n};\n\nfunction __wbg_node_6a9d28205ed5b0d8(arg0) {\n    const ret = getObject(arg0).node;\n    return addHeapObject(ret);\n};\n\nfunction __wbg_msCrypto_adbc770ec9eca9c7(arg0) {\n    const ret = getObject(arg0).msCrypto;\n    return addHeapObject(ret);\n};\n\nfunction __wbg_require_f05d779769764e82() { return handleError(function () {\n    const ret = module.require;\n    return addHeapObject(ret);\n}, arguments) };\n\nfunction __wbg_log_7bb108d119bafbc1(arg0) {\n    console.log(getObject(arg0));\n};\n\nfunction __wbg_log_d047cf0648d2678e(arg0, arg1) {\n    console.log(getObject(arg0), getObject(arg1));\n};\n\nfunction __wbg_get_27fe3dac1c4d0224(arg0, arg1) {\n    const ret = getObject(arg0)[arg1 >>> 0];\n    return addHeapObject(ret);\n};\n\nfunction __wbg_length_e498fbc24f9c1d4f(arg0) {\n    const ret = getObject(arg0).length;\n    return ret;\n};\n\nfunction __wbg_new_b525de17f44a8943() {\n    const ret = new Array();\n    return addHeapObject(ret);\n};\n\nfunction __wbg_newnoargs_2b8b6bd7753c76ba(arg0, arg1) {\n    const ret = new Function(getStringFromWasm0(arg0, arg1));\n    return addHeapObject(ret);\n};\n\nfunction __wbg_next_b7d530c04fd8b217(arg0) {\n    const ret = getObject(arg0).next;\n    return addHeapObject(ret);\n};\n\nfunction __wbg_next_88560ec06a094dea() { return handleError(function (arg0) {\n    const ret = getObject(arg0).next();\n    return addHeapObject(ret);\n}, arguments) };\n\nfunction __wbg_done_1ebec03bbd919843(arg0) {\n    const ret = getObject(arg0).done;\n    return ret;\n};\n\nfunction __wbg_value_6ac8da5cc5b3efda(arg0) {\n    const ret = getObject(arg0).value;\n    return addHeapObject(ret);\n};\n\nfunction __wbg_iterator_55f114446221aa5a() {\n    const ret = Symbol.iterator;\n    return addHeapObject(ret);\n};\n\nfunction __wbg_get_baf4855f9a986186() { return handleError(function (arg0, arg1) {\n    const ret = Reflect.get(getObject(arg0), getObject(arg1));\n    return addHeapObject(ret);\n}, arguments) };\n\nfunction __wbg_call_95d1ea488d03e4e8() { return handleError(function (arg0, arg1) {\n    const ret = getObject(arg0).call(getObject(arg1));\n    return addHeapObject(ret);\n}, arguments) };\n\nfunction __wbg_new_f9876326328f45ed() {\n    const ret = new Object();\n    return addHeapObject(ret);\n};\n\nfunction __wbg_length_ea0846e494e3b16e(arg0) {\n    const ret = getObject(arg0).length;\n    return ret;\n};\n\nfunction __wbg_set_17224bc548dd1d7b(arg0, arg1, arg2) {\n    getObject(arg0)[arg1 >>> 0] = takeObject(arg2);\n};\n\nfunction __wbg_from_67ca20fa722467e6(arg0) {\n    const ret = Array.from(getObject(arg0));\n    return addHeapObject(ret);\n};\n\nfunction __wbg_isArray_39d28997bf6b96b4(arg0) {\n    const ret = Array.isArray(getObject(arg0));\n    return ret;\n};\n\nfunction __wbg_push_49c286f04dd3bf59(arg0, arg1) {\n    const ret = getObject(arg0).push(getObject(arg1));\n    return ret;\n};\n\nfunction __wbg_unshift_06a94bcbcb492eb3(arg0, arg1) {\n    const ret = getObject(arg0).unshift(getObject(arg1));\n    return ret;\n};\n\nfunction __wbg_instanceof_ArrayBuffer_a69f02ee4c4f5065(arg0) {\n    let result;\n    try {\n        result = getObject(arg0) instanceof ArrayBuffer;\n    } catch {\n        result = false;\n    }\n    const ret = result;\n    return ret;\n};\n\nfunction __wbg_new_15d3966e9981a196(arg0, arg1) {\n    const ret = new Error(getStringFromWasm0(arg0, arg1));\n    return addHeapObject(ret);\n};\n\nfunction __wbg_call_9495de66fdbe016b() { return handleError(function (arg0, arg1, arg2) {\n    const ret = getObject(arg0).call(getObject(arg1), getObject(arg2));\n    return addHeapObject(ret);\n}, arguments) };\n\nfunction __wbg_call_96878afb7a8201ca() { return handleError(function (arg0, arg1, arg2, arg3) {\n    const ret = getObject(arg0).call(getObject(arg1), getObject(arg2), getObject(arg3));\n    return addHeapObject(ret);\n}, arguments) };\n\nfunction __wbg_instanceof_Date_e353425d719aa266(arg0) {\n    let result;\n    try {\n        result = getObject(arg0) instanceof Date;\n    } catch {\n        result = false;\n    }\n    const ret = result;\n    return ret;\n};\n\nfunction __wbg_getTime_7c59072d1651a3cf(arg0) {\n    const ret = getObject(arg0).getTime();\n    return ret;\n};\n\nfunction __wbg_new_f127e324c1313064(arg0) {\n    const ret = new Date(getObject(arg0));\n    return addHeapObject(ret);\n};\n\nfunction __wbg_instanceof_Object_f5a826c4da0d4a94(arg0) {\n    let result;\n    try {\n        result = getObject(arg0) instanceof Object;\n    } catch {\n        result = false;\n    }\n    const ret = result;\n    return ret;\n};\n\nfunction __wbg_assign_b0b6530984f36574(arg0, arg1) {\n    const ret = Object.assign(getObject(arg0), getObject(arg1));\n    return addHeapObject(ret);\n};\n\nfunction __wbg_defineProperty_4926f24c724d5310(arg0, arg1, arg2) {\n    const ret = Object.defineProperty(getObject(arg0), getObject(arg1), getObject(arg2));\n    return addHeapObject(ret);\n};\n\nfunction __wbg_entries_4e1315b774245952(arg0) {\n    const ret = Object.entries(getObject(arg0));\n    return addHeapObject(ret);\n};\n\nfunction __wbg_freeze_4dcdbf0b5d9b50f4(arg0) {\n    const ret = Object.freeze(getObject(arg0));\n    return addHeapObject(ret);\n};\n\nfunction __wbg_keys_60443f4f867207f9(arg0) {\n    const ret = Object.keys(getObject(arg0));\n    return addHeapObject(ret);\n};\n\nfunction __wbg_values_7444c4c2ccefdc9b(arg0) {\n    const ret = Object.values(getObject(arg0));\n    return addHeapObject(ret);\n};\n\nfunction __wbg_apply_5435e78b95a524a6() { return handleError(function (arg0, arg1, arg2) {\n    const ret = Reflect.apply(getObject(arg0), getObject(arg1), getObject(arg2));\n    return addHeapObject(ret);\n}, arguments) };\n\nfunction __wbg_deleteProperty_31090878b92a7c0e() { return handleError(function (arg0, arg1) {\n    const ret = Reflect.deleteProperty(getObject(arg0), getObject(arg1));\n    return ret;\n}, arguments) };\n\nfunction __wbg_ownKeys_9efe69be404540aa() { return handleError(function (arg0) {\n    const ret = Reflect.ownKeys(getObject(arg0));\n    return addHeapObject(ret);\n}, arguments) };\n\nfunction __wbg_set_6aa458a4ebdb65cb() { return handleError(function (arg0, arg1, arg2) {\n    const ret = Reflect.set(getObject(arg0), getObject(arg1), getObject(arg2));\n    return ret;\n}, arguments) };\n\nfunction __wbg_buffer_cf65c07de34b9a08(arg0) {\n    const ret = getObject(arg0).buffer;\n    return addHeapObject(ret);\n};\n\nfunction __wbg_concat_040af6c9ba38dd98(arg0, arg1) {\n    const ret = getObject(arg0).concat(getObject(arg1));\n    return addHeapObject(ret);\n};\n\nfunction __wbg_slice_47202b1d012cdc55(arg0, arg1, arg2) {\n    const ret = getObject(arg0).slice(arg1 >>> 0, arg2 >>> 0);\n    return addHeapObject(ret);\n};\n\nfunction __wbg_for_9a885d0d6d415e40(arg0, arg1) {\n    const ret = Symbol.for(getStringFromWasm0(arg0, arg1));\n    return addHeapObject(ret);\n};\n\nfunction __wbg_toString_7a3e0cd68ea2a337(arg0) {\n    const ret = getObject(arg0).toString();\n    return addHeapObject(ret);\n};\n\nfunction __wbg_self_e7c1f827057f6584() { return handleError(function () {\n    const ret = self.self;\n    return addHeapObject(ret);\n}, arguments) };\n\nfunction __wbg_window_a09ec664e14b1b81() { return handleError(function () {\n    const ret = window.window;\n    return addHeapObject(ret);\n}, arguments) };\n\nfunction __wbg_globalThis_87cbb8506fecf3a9() { return handleError(function () {\n    const ret = globalThis.globalThis;\n    return addHeapObject(ret);\n}, arguments) };\n\nfunction __wbg_global_c85a9259e621f3db() { return handleError(function () {\n    const ret = __webpack_require__.g.global;\n    return addHeapObject(ret);\n}, arguments) };\n\nfunction __wbg_newwithbyteoffsetandlength_9fb2f11355ecadf5(arg0, arg1, arg2) {\n    const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);\n    return addHeapObject(ret);\n};\n\nfunction __wbg_new_537b7341ce90bb31(arg0) {\n    const ret = new Uint8Array(getObject(arg0));\n    return addHeapObject(ret);\n};\n\nfunction __wbg_set_17499e8aa4003ebd(arg0, arg1, arg2) {\n    getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n};\n\nfunction __wbg_length_27a2afe8ab42b09f(arg0) {\n    const ret = getObject(arg0).length;\n    return ret;\n};\n\nfunction __wbg_instanceof_Uint8Array_01cebe79ca606cca(arg0) {\n    let result;\n    try {\n        result = getObject(arg0) instanceof Uint8Array;\n    } catch {\n        result = false;\n    }\n    const ret = result;\n    return ret;\n};\n\nfunction __wbg_newwithlength_b56c882b57805732(arg0) {\n    const ret = new Uint8Array(arg0 >>> 0);\n    return addHeapObject(ret);\n};\n\nfunction __wbg_subarray_7526649b91a252a6(arg0, arg1, arg2) {\n    const ret = getObject(arg0).subarray(arg1 >>> 0, arg2 >>> 0);\n    return addHeapObject(ret);\n};\n\nfunction __wbindgen_debug_string(arg0, arg1) {\n    const ret = debugString(getObject(arg1));\n    const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len0 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len0;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n};\n\nfunction __wbindgen_throw(arg0, arg1) {\n    throw new Error(getStringFromWasm0(arg0, arg1));\n};\n\nfunction __wbindgen_memory() {\n    const ret = wasm.memory;\n    return addHeapObject(ret);\n};\n\n\n\n//# sourceURL=webpack://experiments/./node_modules/@automerge/automerge-wasm/bundler/automerge_wasm_bg.js?");

/***/ }),

/***/ "./node_modules/@automerge/automerge/dist/mjs/conflicts.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@automerge/automerge/dist/mjs/conflicts.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   stableConflictAt: () => (/* binding */ stableConflictAt),\n/* harmony export */   unstableConflictAt: () => (/* binding */ unstableConflictAt)\n/* harmony export */ });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"./node_modules/@automerge/automerge/dist/mjs/types.js\");\n/* harmony import */ var _text__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./text */ \"./node_modules/@automerge/automerge/dist/mjs/text.js\");\n/* harmony import */ var _proxies__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./proxies */ \"./node_modules/@automerge/automerge/dist/mjs/proxies.js\");\n\n\n\nfunction stableConflictAt(context, objectId, prop) {\n    return conflictAt(context, objectId, prop, true, (context, conflictId) => {\n        return new _text__WEBPACK_IMPORTED_MODULE_1__.Text(context.text(conflictId));\n    });\n}\nfunction unstableConflictAt(context, objectId, prop) {\n    return conflictAt(context, objectId, prop, true, (context, conflictId) => {\n        return context.text(conflictId);\n    });\n}\nfunction conflictAt(context, objectId, prop, textV2, handleText) {\n    const values = context.getAll(objectId, prop);\n    if (values.length <= 1) {\n        return;\n    }\n    const result = {};\n    for (const fullVal of values) {\n        switch (fullVal[0]) {\n            case \"map\":\n                result[fullVal[1]] = (0,_proxies__WEBPACK_IMPORTED_MODULE_2__.mapProxy)(context, fullVal[1], textV2, [prop], true);\n                break;\n            case \"list\":\n                result[fullVal[1]] = (0,_proxies__WEBPACK_IMPORTED_MODULE_2__.listProxy)(context, fullVal[1], textV2, [prop], true);\n                break;\n            case \"text\":\n                result[fullVal[1]] = handleText(context, fullVal[1]);\n                break;\n            case \"str\":\n            case \"uint\":\n            case \"int\":\n            case \"f64\":\n            case \"boolean\":\n            case \"bytes\":\n            case \"null\":\n                result[fullVal[2]] = fullVal[1];\n                break;\n            case \"counter\":\n                result[fullVal[2]] = new _types__WEBPACK_IMPORTED_MODULE_0__.Counter(fullVal[1]);\n                break;\n            case \"timestamp\":\n                result[fullVal[2]] = new Date(fullVal[1]);\n                break;\n            default:\n                throw RangeError(`datatype ${fullVal[0]} unimplemented`);\n        }\n    }\n    return result;\n}\n\n\n//# sourceURL=webpack://experiments/./node_modules/@automerge/automerge/dist/mjs/conflicts.js?");

/***/ }),

/***/ "./node_modules/@automerge/automerge/dist/mjs/constants.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@automerge/automerge/dist/mjs/constants.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   COUNTER: () => (/* binding */ COUNTER),\n/* harmony export */   F64: () => (/* binding */ F64),\n/* harmony export */   INT: () => (/* binding */ INT),\n/* harmony export */   IS_PROXY: () => (/* binding */ IS_PROXY),\n/* harmony export */   OBJECT_ID: () => (/* binding */ OBJECT_ID),\n/* harmony export */   STATE: () => (/* binding */ STATE),\n/* harmony export */   TEXT: () => (/* binding */ TEXT),\n/* harmony export */   TRACE: () => (/* binding */ TRACE),\n/* harmony export */   UINT: () => (/* binding */ UINT)\n/* harmony export */ });\n// Properties of the document root object\nconst STATE = Symbol.for(\"_am_meta\"); // symbol used to hide application metadata on automerge objects\nconst TRACE = Symbol.for(\"_am_trace\"); // used for debugging\nconst OBJECT_ID = Symbol.for(\"_am_objectId\"); // symbol used to hide the object id on automerge objects\nconst IS_PROXY = Symbol.for(\"_am_isProxy\"); // symbol used to test if the document is a proxy object\nconst UINT = Symbol.for(\"_am_uint\");\nconst INT = Symbol.for(\"_am_int\");\nconst F64 = Symbol.for(\"_am_f64\");\nconst COUNTER = Symbol.for(\"_am_counter\");\nconst TEXT = Symbol.for(\"_am_text\");\n\n\n//# sourceURL=webpack://experiments/./node_modules/@automerge/automerge/dist/mjs/constants.js?");

/***/ }),

/***/ "./node_modules/@automerge/automerge/dist/mjs/counter.js":
/*!***************************************************************!*\
  !*** ./node_modules/@automerge/automerge/dist/mjs/counter.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Counter: () => (/* binding */ Counter),\n/* harmony export */   getWriteableCounter: () => (/* binding */ getWriteableCounter)\n/* harmony export */ });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"./node_modules/@automerge/automerge/dist/mjs/constants.js\");\n\n/**\n * The most basic CRDT: an integer value that can be changed only by\n * incrementing and decrementing. Since addition of integers is commutative,\n * the value trivially converges.\n */\nclass Counter {\n    constructor(value) {\n        this.value = value || 0;\n        Reflect.defineProperty(this, _constants__WEBPACK_IMPORTED_MODULE_0__.COUNTER, { value: true });\n    }\n    /**\n     * A peculiar JavaScript language feature from its early days: if the object\n     * `x` has a `valueOf()` method that returns a number, you can use numerical\n     * operators on the object `x` directly, such as `x + 1` or `x < 4`.\n     * This method is also called when coercing a value to a string by\n     * concatenating it with another string, as in `x + ''`.\n     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf\n     */\n    valueOf() {\n        return this.value;\n    }\n    /**\n     * Returns the counter value as a decimal string. If `x` is a counter object,\n     * this method is called e.g. when you do `['value: ', x].join('')` or when\n     * you use string interpolation: `value: ${x}`.\n     */\n    toString() {\n        return this.valueOf().toString();\n    }\n    /**\n     * Returns the counter value, so that a JSON serialization of an Automerge\n     * document represents the counter simply as an integer.\n     */\n    toJSON() {\n        return this.value;\n    }\n}\n/**\n * An instance of this class is used when a counter is accessed within a change\n * callback.\n */\nclass WriteableCounter extends Counter {\n    constructor(value, context, path, objectId, key) {\n        super(value);\n        this.context = context;\n        this.path = path;\n        this.objectId = objectId;\n        this.key = key;\n    }\n    /**\n     * Increases the value of the counter by `delta`. If `delta` is not given,\n     * increases the value of the counter by 1.\n     */\n    increment(delta) {\n        delta = typeof delta === \"number\" ? delta : 1;\n        this.context.increment(this.objectId, this.key, delta);\n        this.value += delta;\n        return this.value;\n    }\n    /**\n     * Decreases the value of the counter by `delta`. If `delta` is not given,\n     * decreases the value of the counter by 1.\n     */\n    decrement(delta) {\n        return this.increment(typeof delta === \"number\" ? -delta : -1);\n    }\n}\n/**\n * Returns an instance of `WriteableCounter` for use in a change callback.\n * `context` is the proxy context that keeps track of the mutations.\n * `objectId` is the ID of the object containing the counter, and `key` is\n * the property name (key in map, or index in list) where the counter is\n * located.\n */\nfunction getWriteableCounter(value, context, path, objectId, key) {\n    return new WriteableCounter(value, context, path, objectId, key);\n}\n//module.exports = { Counter, getWriteableCounter }\n\n\n//# sourceURL=webpack://experiments/./node_modules/@automerge/automerge/dist/mjs/counter.js?");

/***/ }),

/***/ "./node_modules/@automerge/automerge/dist/mjs/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@automerge/automerge/dist/mjs/index.js ***!
  \*************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Counter: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_0__.Counter),\n/* harmony export */   Float64: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_0__.Float64),\n/* harmony export */   Int: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_0__.Int),\n/* harmony export */   Text: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_0__.Text),\n/* harmony export */   Uint: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_0__.Uint),\n/* harmony export */   applyChanges: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_0__.applyChanges),\n/* harmony export */   change: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_0__.change),\n/* harmony export */   clone: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_0__.clone),\n/* harmony export */   decodeChange: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_0__.decodeChange),\n/* harmony export */   decodeSyncMessage: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_0__.decodeSyncMessage),\n/* harmony export */   decodeSyncState: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_0__.decodeSyncState),\n/* harmony export */   dump: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_0__.dump),\n/* harmony export */   emptyChange: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_0__.emptyChange),\n/* harmony export */   encodeChange: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_0__.encodeChange),\n/* harmony export */   encodeSyncMessage: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_0__.encodeSyncMessage),\n/* harmony export */   encodeSyncState: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_0__.encodeSyncState),\n/* harmony export */   equals: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_0__.equals),\n/* harmony export */   free: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_0__.free),\n/* harmony export */   from: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_0__.from),\n/* harmony export */   generateSyncMessage: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_0__.generateSyncMessage),\n/* harmony export */   getActorId: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_0__.getActorId),\n/* harmony export */   getAllChanges: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_0__.getAllChanges),\n/* harmony export */   getBackend: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_0__.getBackend),\n/* harmony export */   getChanges: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_0__.getChanges),\n/* harmony export */   getConflicts: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_0__.getConflicts),\n/* harmony export */   getHeads: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_0__.getHeads),\n/* harmony export */   getHistory: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_0__.getHistory),\n/* harmony export */   getLastLocalChange: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_0__.getLastLocalChange),\n/* harmony export */   getMissingDeps: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_0__.getMissingDeps),\n/* harmony export */   getObjectId: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_0__.getObjectId),\n/* harmony export */   init: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_0__.init),\n/* harmony export */   initSyncState: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_0__.initSyncState),\n/* harmony export */   isAutomerge: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_0__.isAutomerge),\n/* harmony export */   load: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_0__.load),\n/* harmony export */   loadIncremental: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_0__.loadIncremental),\n/* harmony export */   merge: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_0__.merge),\n/* harmony export */   receiveSyncMessage: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_0__.receiveSyncMessage),\n/* harmony export */   save: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_0__.save),\n/* harmony export */   saveIncremental: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_0__.saveIncremental),\n/* harmony export */   toJS: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_0__.toJS),\n/* harmony export */   unstable: () => (/* reexport module object */ _unstable__WEBPACK_IMPORTED_MODULE_1__),\n/* harmony export */   use: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_0__.use),\n/* harmony export */   uuid: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_0__.uuid),\n/* harmony export */   view: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_0__.view)\n/* harmony export */ });\n/* harmony import */ var _stable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./stable */ \"./node_modules/@automerge/automerge/dist/mjs/stable.js\");\n/* harmony import */ var _unstable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./unstable */ \"./node_modules/@automerge/automerge/dist/mjs/unstable.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_stable__WEBPACK_IMPORTED_MODULE_0__, _unstable__WEBPACK_IMPORTED_MODULE_1__]);\n([_stable__WEBPACK_IMPORTED_MODULE_0__, _unstable__WEBPACK_IMPORTED_MODULE_1__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n/**\n * # Automerge\n *\n * This library provides the core automerge data structure and sync algorithms.\n * Other libraries can be built on top of this one which provide IO and\n * persistence.\n *\n * An automerge document can be though of an immutable POJO (plain old javascript\n * object) which `automerge` tracks the history of, allowing it to be merged with\n * any other automerge document.\n *\n * ## Creating and modifying a document\n *\n * You can create a document with {@link init} or {@link from} and then make\n * changes to it with {@link change}, you can merge two documents with {@link\n * merge}.\n *\n * ```ts\n * import * as automerge from \"@automerge/automerge\"\n *\n * type DocType = {ideas: Array<automerge.Text>}\n *\n * let doc1 = automerge.init<DocType>()\n * doc1 = automerge.change(doc1, d => {\n *     d.ideas = [new automerge.Text(\"an immutable document\")]\n * })\n *\n * let doc2 = automerge.init<DocType>()\n * doc2 = automerge.merge(doc2, automerge.clone(doc1))\n * doc2 = automerge.change<DocType>(doc2, d => {\n *     d.ideas.push(new automerge.Text(\"which records it's history\"))\n * })\n *\n * // Note the `automerge.clone` call, see the \"cloning\" section of this readme for\n * // more detail\n * doc1 = automerge.merge(doc1, automerge.clone(doc2))\n * doc1 = automerge.change(doc1, d => {\n *     d.ideas[0].deleteAt(13, 8)\n *     d.ideas[0].insertAt(13, \"object\")\n * })\n *\n * let doc3 = automerge.merge(doc1, doc2)\n * // doc3 is now {ideas: [\"an immutable object\", \"which records it's history\"]}\n * ```\n *\n * ## Applying changes from another document\n *\n * You can get a representation of the result of the last {@link change} you made\n * to a document with {@link getLastLocalChange} and you can apply that change to\n * another document using {@link applyChanges}.\n *\n * If you need to get just the changes which are in one document but not in another\n * you can use {@link getHeads} to get the heads of the document without the\n * changes and then {@link getMissingDeps}, passing the result of {@link getHeads}\n * on the document with the changes.\n *\n * ## Saving and loading documents\n *\n * You can {@link save} a document to generate a compresed binary representation of\n * the document which can be loaded with {@link load}. If you have a document which\n * you have recently made changes to you can generate recent changes with {@link\n * saveIncremental}, this will generate all the changes since you last called\n * `saveIncremental`, the changes generated can be applied to another document with\n * {@link loadIncremental}.\n *\n * ## Viewing different versions of a document\n *\n * Occasionally you may wish to explicitly step to a different point in a document\n * history. One common reason to do this is if you need to obtain a set of changes\n * which take the document from one state to another in order to send those changes\n * to another peer (or to save them somewhere). You can use {@link view} to do this.\n *\n * ```ts\n * import * as automerge from \"@automerge/automerge\"\n * import * as assert from \"assert\"\n *\n * let doc = automerge.from({\n *   key1: \"value1\",\n * })\n *\n * // Make a clone of the document at this point, maybe this is actually on another\n * // peer.\n * let doc2 = automerge.clone < any > doc\n *\n * let heads = automerge.getHeads(doc)\n *\n * doc =\n *   automerge.change <\n *   any >\n *   (doc,\n *   d => {\n *     d.key2 = \"value2\"\n *   })\n *\n * doc =\n *   automerge.change <\n *   any >\n *   (doc,\n *   d => {\n *     d.key3 = \"value3\"\n *   })\n *\n * // At this point we've generated two separate changes, now we want to send\n * // just those changes to someone else\n *\n * // view is a cheap reference based copy of a document at a given set of heads\n * let before = automerge.view(doc, heads)\n *\n * // This view doesn't show the last two changes in the document state\n * assert.deepEqual(before, {\n *   key1: \"value1\",\n * })\n *\n * // Get the changes to send to doc2\n * let changes = automerge.getChanges(before, doc)\n *\n * // Apply the changes at doc2\n * doc2 = automerge.applyChanges < any > (doc2, changes)[0]\n * assert.deepEqual(doc2, {\n *   key1: \"value1\",\n *   key2: \"value2\",\n *   key3: \"value3\",\n * })\n * ```\n *\n * If you have a {@link view} of a document which you want to make changes to you\n * can {@link clone} the viewed document.\n *\n * ## Syncing\n *\n * The sync protocol is stateful. This means that we start by creating a {@link\n * SyncState} for each peer we are communicating with using {@link initSyncState}.\n * Then we generate a message to send to the peer by calling {@link\n * generateSyncMessage}. When we receive a message from the peer we call {@link\n * receiveSyncMessage}. Here's a simple example of a loop which just keeps two\n * peers in sync.\n *\n * ```ts\n * let sync1 = automerge.initSyncState()\n * let msg: Uint8Array | null\n * ;[sync1, msg] = automerge.generateSyncMessage(doc1, sync1)\n *\n * while (true) {\n *   if (msg != null) {\n *     network.send(msg)\n *   }\n *   let resp: Uint8Array =\n *     (network.receive()[(doc1, sync1, _ignore)] =\n *     automerge.receiveSyncMessage(doc1, sync1, resp)[(sync1, msg)] =\n *       automerge.generateSyncMessage(doc1, sync1))\n * }\n * ```\n *\n * ## Conflicts\n *\n * The only time conflicts occur in automerge documents is in concurrent\n * assignments to the same key in an object. In this case automerge\n * deterministically chooses an arbitrary value to present to the application but\n * you can examine the conflicts using {@link getConflicts}.\n *\n * ```\n * import * as automerge from \"@automerge/automerge\"\n *\n * type Profile = {\n *     pets: Array<{name: string, type: string}>\n * }\n *\n * let doc1 = automerge.init<Profile>(\"aaaa\")\n * doc1 = automerge.change(doc1, d => {\n *     d.pets = [{name: \"Lassie\", type: \"dog\"}]\n * })\n * let doc2 = automerge.init<Profile>(\"bbbb\")\n * doc2 = automerge.merge(doc2, automerge.clone(doc1))\n *\n * doc2 = automerge.change(doc2, d => {\n *     d.pets[0].name = \"Beethoven\"\n * })\n *\n * doc1 = automerge.change(doc1, d => {\n *     d.pets[0].name = \"Babe\"\n * })\n *\n * const doc3 = automerge.merge(doc1, doc2)\n *\n * // Note that here we pass `doc3.pets`, not `doc3`\n * let conflicts = automerge.getConflicts(doc3.pets[0], \"name\")\n *\n * // The two conflicting values are the keys of the conflicts object\n * assert.deepEqual(Object.values(conflicts), [\"Babe\", Beethoven\"])\n * ```\n *\n * ## Actor IDs\n *\n * By default automerge will generate a random actor ID for you, but most methods\n * for creating a document allow you to set the actor ID. You can get the actor ID\n * associated with the document by calling {@link getActorId}. Actor IDs must not\n * be used in concurrent threads of executiong - all changes by a given actor ID\n * are expected to be sequential.\n *\n * ## Listening to patches\n *\n * Sometimes you want to respond to changes made to an automerge document. In this\n * case you can use the {@link PatchCallback} type to receive notifications when\n * changes have been made.\n *\n * ## Cloning\n *\n * Currently you cannot make mutating changes (i.e. call {@link change}) to a\n * document which you have two pointers to. For example, in this code:\n *\n * ```javascript\n * let doc1 = automerge.init()\n * let doc2 = automerge.change(doc1, d => (d.key = \"value\"))\n * ```\n *\n * `doc1` and `doc2` are both pointers to the same state. Any attempt to call\n * mutating methods on `doc1` will now result in an error like\n *\n *     Attempting to change an out of date document\n *\n * If you encounter this you need to clone the original document, the above sample\n * would work as:\n *\n * ```javascript\n * let doc1 = automerge.init()\n * let doc2 = automerge.change(automerge.clone(doc1), d => (d.key = \"value\"))\n * ```\n * @packageDocumentation\n *\n * ## The {@link unstable} module\n *\n * We are working on some changes to automerge which are not yet complete and\n * will result in backwards incompatible API changes. Once these changes are\n * ready for production use we will release a new major version of automerge.\n * However, until that point you can use the {@link unstable} module to try out\n * the new features, documents from the {@link unstable} module are\n * interoperable with documents from the main module. Please see the docs for\n * the {@link unstable} module for more details.\n */\n\n\n\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://experiments/./node_modules/@automerge/automerge/dist/mjs/index.js?");

/***/ }),

/***/ "./node_modules/@automerge/automerge/dist/mjs/internal_state.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@automerge/automerge/dist/mjs/internal_state.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _is_proxy: () => (/* binding */ _is_proxy),\n/* harmony export */   _obj: () => (/* binding */ _obj),\n/* harmony export */   _state: () => (/* binding */ _state),\n/* harmony export */   _trace: () => (/* binding */ _trace)\n/* harmony export */ });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"./node_modules/@automerge/automerge/dist/mjs/constants.js\");\n\nfunction _state(doc, checkroot = true) {\n    if (typeof doc !== \"object\") {\n        throw new RangeError(\"must be the document root\");\n    }\n    const state = Reflect.get(doc, _constants__WEBPACK_IMPORTED_MODULE_0__.STATE);\n    if (state === undefined ||\n        state == null ||\n        (checkroot && _obj(doc) !== \"_root\")) {\n        throw new RangeError(\"must be the document root\");\n    }\n    return state;\n}\nfunction _trace(doc) {\n    return Reflect.get(doc, _constants__WEBPACK_IMPORTED_MODULE_0__.TRACE);\n}\nfunction _obj(doc) {\n    if (!(typeof doc === \"object\") || doc === null) {\n        return null;\n    }\n    return Reflect.get(doc, _constants__WEBPACK_IMPORTED_MODULE_0__.OBJECT_ID);\n}\nfunction _is_proxy(doc) {\n    return !!Reflect.get(doc, _constants__WEBPACK_IMPORTED_MODULE_0__.IS_PROXY);\n}\n\n\n//# sourceURL=webpack://experiments/./node_modules/@automerge/automerge/dist/mjs/internal_state.js?");

/***/ }),

/***/ "./node_modules/@automerge/automerge/dist/mjs/low_level.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@automerge/automerge/dist/mjs/low_level.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ApiHandler: () => (/* binding */ ApiHandler),\n/* harmony export */   UseApi: () => (/* binding */ UseApi)\n/* harmony export */ });\nfunction UseApi(api) {\n    for (const k in api) {\n        // eslint-disable-next-line @typescript-eslint/no-extra-semi,@typescript-eslint/no-explicit-any\n        ;\n        ApiHandler[k] = api[k];\n    }\n}\n/* eslint-disable */\nconst ApiHandler = {\n    create(textV2, actor) {\n        throw new RangeError(\"Automerge.use() not called\");\n    },\n    load(data, textV2, actor) {\n        throw new RangeError(\"Automerge.use() not called (load)\");\n    },\n    encodeChange(change) {\n        throw new RangeError(\"Automerge.use() not called (encodeChange)\");\n    },\n    decodeChange(change) {\n        throw new RangeError(\"Automerge.use() not called (decodeChange)\");\n    },\n    initSyncState() {\n        throw new RangeError(\"Automerge.use() not called (initSyncState)\");\n    },\n    encodeSyncMessage(message) {\n        throw new RangeError(\"Automerge.use() not called (encodeSyncMessage)\");\n    },\n    decodeSyncMessage(msg) {\n        throw new RangeError(\"Automerge.use() not called (decodeSyncMessage)\");\n    },\n    encodeSyncState(state) {\n        throw new RangeError(\"Automerge.use() not called (encodeSyncState)\");\n    },\n    decodeSyncState(data) {\n        throw new RangeError(\"Automerge.use() not called (decodeSyncState)\");\n    },\n    exportSyncState(state) {\n        throw new RangeError(\"Automerge.use() not called (exportSyncState)\");\n    },\n    importSyncState(state) {\n        throw new RangeError(\"Automerge.use() not called (importSyncState)\");\n    },\n};\n/* eslint-enable */\n\n\n//# sourceURL=webpack://experiments/./node_modules/@automerge/automerge/dist/mjs/low_level.js?");

/***/ }),

/***/ "./node_modules/@automerge/automerge/dist/mjs/numbers.js":
/*!***************************************************************!*\
  !*** ./node_modules/@automerge/automerge/dist/mjs/numbers.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Float64: () => (/* binding */ Float64),\n/* harmony export */   Int: () => (/* binding */ Int),\n/* harmony export */   Uint: () => (/* binding */ Uint)\n/* harmony export */ });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"./node_modules/@automerge/automerge/dist/mjs/constants.js\");\n// Convenience classes to allow users to strictly specify the number type they want\n\nclass Int {\n    constructor(value) {\n        if (!(Number.isInteger(value) &&\n            value <= Number.MAX_SAFE_INTEGER &&\n            value >= Number.MIN_SAFE_INTEGER)) {\n            throw new RangeError(`Value ${value} cannot be a uint`);\n        }\n        this.value = value;\n        Reflect.defineProperty(this, _constants__WEBPACK_IMPORTED_MODULE_0__.INT, { value: true });\n        Object.freeze(this);\n    }\n}\nclass Uint {\n    constructor(value) {\n        if (!(Number.isInteger(value) &&\n            value <= Number.MAX_SAFE_INTEGER &&\n            value >= 0)) {\n            throw new RangeError(`Value ${value} cannot be a uint`);\n        }\n        this.value = value;\n        Reflect.defineProperty(this, _constants__WEBPACK_IMPORTED_MODULE_0__.UINT, { value: true });\n        Object.freeze(this);\n    }\n}\nclass Float64 {\n    constructor(value) {\n        if (typeof value !== \"number\") {\n            throw new RangeError(`Value ${value} cannot be a float64`);\n        }\n        this.value = value || 0.0;\n        Reflect.defineProperty(this, _constants__WEBPACK_IMPORTED_MODULE_0__.F64, { value: true });\n        Object.freeze(this);\n    }\n}\n\n\n//# sourceURL=webpack://experiments/./node_modules/@automerge/automerge/dist/mjs/numbers.js?");

/***/ }),

/***/ "./node_modules/@automerge/automerge/dist/mjs/proxies.js":
/*!***************************************************************!*\
  !*** ./node_modules/@automerge/automerge/dist/mjs/proxies.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   listProxy: () => (/* binding */ listProxy),\n/* harmony export */   mapProxy: () => (/* binding */ mapProxy),\n/* harmony export */   rootProxy: () => (/* binding */ rootProxy),\n/* harmony export */   textProxy: () => (/* binding */ textProxy)\n/* harmony export */ });\n/* harmony import */ var _text__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./text */ \"./node_modules/@automerge/automerge/dist/mjs/text.js\");\n/* harmony import */ var _counter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./counter */ \"./node_modules/@automerge/automerge/dist/mjs/counter.js\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants */ \"./node_modules/@automerge/automerge/dist/mjs/constants.js\");\n/* harmony import */ var _raw_string__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./raw_string */ \"./node_modules/@automerge/automerge/dist/mjs/raw_string.js\");\n/* eslint-disable  @typescript-eslint/no-explicit-any */\n\n\n\n\nfunction parseListIndex(key) {\n    if (typeof key === \"string\" && /^[0-9]+$/.test(key))\n        key = parseInt(key, 10);\n    if (typeof key !== \"number\") {\n        return key;\n    }\n    if (key < 0 || isNaN(key) || key === Infinity || key === -Infinity) {\n        throw new RangeError(\"A list index must be positive, but you passed \" + key);\n    }\n    return key;\n}\nfunction valueAt(target, prop) {\n    const { context, objectId, path, readonly, heads, textV2 } = target;\n    const value = context.getWithType(objectId, prop, heads);\n    if (value === null) {\n        return;\n    }\n    const datatype = value[0];\n    const val = value[1];\n    switch (datatype) {\n        case undefined:\n            return;\n        case \"map\":\n            return mapProxy(context, val, textV2, [...path, prop], readonly, heads);\n        case \"list\":\n            return listProxy(context, val, textV2, [...path, prop], readonly, heads);\n        case \"text\":\n            if (textV2) {\n                return context.text(val, heads);\n            }\n            else {\n                return textProxy(context, val, [...path, prop], readonly, heads);\n            }\n        case \"str\":\n            return val;\n        case \"uint\":\n            return val;\n        case \"int\":\n            return val;\n        case \"f64\":\n            return val;\n        case \"boolean\":\n            return val;\n        case \"null\":\n            return null;\n        case \"bytes\":\n            return val;\n        case \"timestamp\":\n            return val;\n        case \"counter\": {\n            if (readonly) {\n                return new _counter__WEBPACK_IMPORTED_MODULE_1__.Counter(val);\n            }\n            else {\n                const counter = (0,_counter__WEBPACK_IMPORTED_MODULE_1__.getWriteableCounter)(val, context, path, objectId, prop);\n                return counter;\n            }\n        }\n        default:\n            throw RangeError(`datatype ${datatype} unimplemented`);\n    }\n}\nfunction import_value(value, textV2) {\n    switch (typeof value) {\n        case \"object\":\n            if (value == null) {\n                return [null, \"null\"];\n            }\n            else if (value[_constants__WEBPACK_IMPORTED_MODULE_2__.UINT]) {\n                return [value.value, \"uint\"];\n            }\n            else if (value[_constants__WEBPACK_IMPORTED_MODULE_2__.INT]) {\n                return [value.value, \"int\"];\n            }\n            else if (value[_constants__WEBPACK_IMPORTED_MODULE_2__.F64]) {\n                return [value.value, \"f64\"];\n            }\n            else if (value[_constants__WEBPACK_IMPORTED_MODULE_2__.COUNTER]) {\n                return [value.value, \"counter\"];\n            }\n            else if (value instanceof Date) {\n                return [value.getTime(), \"timestamp\"];\n            }\n            else if (value instanceof _raw_string__WEBPACK_IMPORTED_MODULE_3__.RawString) {\n                return [value.val, \"str\"];\n            }\n            else if (value instanceof _text__WEBPACK_IMPORTED_MODULE_0__.Text) {\n                return [value, \"text\"];\n            }\n            else if (value instanceof Uint8Array) {\n                return [value, \"bytes\"];\n            }\n            else if (value instanceof Array) {\n                return [value, \"list\"];\n            }\n            else if (Object.getPrototypeOf(value) === Object.getPrototypeOf({})) {\n                return [value, \"map\"];\n            }\n            else if (value[_constants__WEBPACK_IMPORTED_MODULE_2__.OBJECT_ID]) {\n                throw new RangeError(\"Cannot create a reference to an existing document object\");\n            }\n            else {\n                throw new RangeError(`Cannot assign unknown object: ${value}`);\n            }\n        case \"boolean\":\n            return [value, \"boolean\"];\n        case \"number\":\n            if (Number.isInteger(value)) {\n                return [value, \"int\"];\n            }\n            else {\n                return [value, \"f64\"];\n            }\n        case \"string\":\n            if (textV2) {\n                return [value, \"text\"];\n            }\n            else {\n                return [value, \"str\"];\n            }\n        default:\n            throw new RangeError(`Unsupported type of value: ${typeof value}`);\n    }\n}\nconst MapHandler = {\n    get(target, key) {\n        const { context, objectId, cache } = target;\n        if (key === Symbol.toStringTag) {\n            return target[Symbol.toStringTag];\n        }\n        if (key === _constants__WEBPACK_IMPORTED_MODULE_2__.OBJECT_ID)\n            return objectId;\n        if (key === _constants__WEBPACK_IMPORTED_MODULE_2__.IS_PROXY)\n            return true;\n        if (key === _constants__WEBPACK_IMPORTED_MODULE_2__.TRACE)\n            return target.trace;\n        if (key === _constants__WEBPACK_IMPORTED_MODULE_2__.STATE)\n            return { handle: context };\n        if (!cache[key]) {\n            cache[key] = valueAt(target, key);\n        }\n        return cache[key];\n    },\n    set(target, key, val) {\n        const { context, objectId, path, readonly, frozen, textV2 } = target;\n        target.cache = {}; // reset cache on set\n        if (val && val[_constants__WEBPACK_IMPORTED_MODULE_2__.OBJECT_ID]) {\n            throw new RangeError(\"Cannot create a reference to an existing document object\");\n        }\n        if (key === _constants__WEBPACK_IMPORTED_MODULE_2__.TRACE) {\n            target.trace = val;\n            return true;\n        }\n        const [value, datatype] = import_value(val, textV2);\n        if (frozen) {\n            throw new RangeError(\"Attempting to use an outdated Automerge document\");\n        }\n        if (readonly) {\n            throw new RangeError(`Object property \"${key}\" cannot be modified`);\n        }\n        switch (datatype) {\n            case \"list\": {\n                const list = context.putObject(objectId, key, []);\n                const proxyList = listProxy(context, list, textV2, [...path, key], readonly);\n                for (let i = 0; i < value.length; i++) {\n                    proxyList[i] = value[i];\n                }\n                break;\n            }\n            case \"text\": {\n                if (textV2) {\n                    assertString(value);\n                    context.putObject(objectId, key, value);\n                }\n                else {\n                    assertText(value);\n                    const text = context.putObject(objectId, key, \"\");\n                    const proxyText = textProxy(context, text, [...path, key], readonly);\n                    for (let i = 0; i < value.length; i++) {\n                        proxyText[i] = value.get(i);\n                    }\n                }\n                break;\n            }\n            case \"map\": {\n                const map = context.putObject(objectId, key, {});\n                const proxyMap = mapProxy(context, map, textV2, [...path, key], readonly);\n                for (const key in value) {\n                    proxyMap[key] = value[key];\n                }\n                break;\n            }\n            default:\n                context.put(objectId, key, value, datatype);\n        }\n        return true;\n    },\n    deleteProperty(target, key) {\n        const { context, objectId, readonly } = target;\n        target.cache = {}; // reset cache on delete\n        if (readonly) {\n            throw new RangeError(`Object property \"${key}\" cannot be modified`);\n        }\n        context.delete(objectId, key);\n        return true;\n    },\n    has(target, key) {\n        const value = this.get(target, key);\n        return value !== undefined;\n    },\n    getOwnPropertyDescriptor(target, key) {\n        // const { context, objectId } = target\n        const value = this.get(target, key);\n        if (typeof value !== \"undefined\") {\n            return {\n                configurable: true,\n                enumerable: true,\n                value,\n            };\n        }\n    },\n    ownKeys(target) {\n        const { context, objectId, heads } = target;\n        // FIXME - this is a tmp workaround until fix the dupe key bug in keys()\n        const keys = context.keys(objectId, heads);\n        return [...new Set(keys)];\n    },\n};\nconst ListHandler = {\n    get(target, index) {\n        const { context, objectId, heads } = target;\n        index = parseListIndex(index);\n        if (index === Symbol.hasInstance) {\n            return (instance) => {\n                return Array.isArray(instance);\n            };\n        }\n        if (index === Symbol.toStringTag) {\n            return target[Symbol.toStringTag];\n        }\n        if (index === _constants__WEBPACK_IMPORTED_MODULE_2__.OBJECT_ID)\n            return objectId;\n        if (index === _constants__WEBPACK_IMPORTED_MODULE_2__.IS_PROXY)\n            return true;\n        if (index === _constants__WEBPACK_IMPORTED_MODULE_2__.TRACE)\n            return target.trace;\n        if (index === _constants__WEBPACK_IMPORTED_MODULE_2__.STATE)\n            return { handle: context };\n        if (index === \"length\")\n            return context.length(objectId, heads);\n        if (typeof index === \"number\") {\n            return valueAt(target, index);\n        }\n        else {\n            return listMethods(target)[index];\n        }\n    },\n    set(target, index, val) {\n        const { context, objectId, path, readonly, frozen, textV2 } = target;\n        index = parseListIndex(index);\n        if (val && val[_constants__WEBPACK_IMPORTED_MODULE_2__.OBJECT_ID]) {\n            throw new RangeError(\"Cannot create a reference to an existing document object\");\n        }\n        if (index === _constants__WEBPACK_IMPORTED_MODULE_2__.TRACE) {\n            target.trace = val;\n            return true;\n        }\n        if (typeof index == \"string\") {\n            throw new RangeError(\"list index must be a number\");\n        }\n        const [value, datatype] = import_value(val, textV2);\n        if (frozen) {\n            throw new RangeError(\"Attempting to use an outdated Automerge document\");\n        }\n        if (readonly) {\n            throw new RangeError(`Object property \"${index}\" cannot be modified`);\n        }\n        switch (datatype) {\n            case \"list\": {\n                let list;\n                if (index >= context.length(objectId)) {\n                    list = context.insertObject(objectId, index, []);\n                }\n                else {\n                    list = context.putObject(objectId, index, []);\n                }\n                const proxyList = listProxy(context, list, textV2, [...path, index], readonly);\n                proxyList.splice(0, 0, ...value);\n                break;\n            }\n            case \"text\": {\n                if (textV2) {\n                    assertString(value);\n                    if (index >= context.length(objectId)) {\n                        context.insertObject(objectId, index, value);\n                    }\n                    else {\n                        context.putObject(objectId, index, value);\n                    }\n                }\n                else {\n                    let text;\n                    assertText(value);\n                    if (index >= context.length(objectId)) {\n                        text = context.insertObject(objectId, index, \"\");\n                    }\n                    else {\n                        text = context.putObject(objectId, index, \"\");\n                    }\n                    const proxyText = textProxy(context, text, [...path, index], readonly);\n                    proxyText.splice(0, 0, ...value);\n                }\n                break;\n            }\n            case \"map\": {\n                let map;\n                if (index >= context.length(objectId)) {\n                    map = context.insertObject(objectId, index, {});\n                }\n                else {\n                    map = context.putObject(objectId, index, {});\n                }\n                const proxyMap = mapProxy(context, map, textV2, [...path, index], readonly);\n                for (const key in value) {\n                    proxyMap[key] = value[key];\n                }\n                break;\n            }\n            default:\n                if (index >= context.length(objectId)) {\n                    context.insert(objectId, index, value, datatype);\n                }\n                else {\n                    context.put(objectId, index, value, datatype);\n                }\n        }\n        return true;\n    },\n    deleteProperty(target, index) {\n        const { context, objectId } = target;\n        index = parseListIndex(index);\n        const elem = context.get(objectId, index);\n        if (elem != null && elem[0] == \"counter\") {\n            throw new TypeError(\"Unsupported operation: deleting a counter from a list\");\n        }\n        context.delete(objectId, index);\n        return true;\n    },\n    has(target, index) {\n        const { context, objectId, heads } = target;\n        index = parseListIndex(index);\n        if (typeof index === \"number\") {\n            return index < context.length(objectId, heads);\n        }\n        return index === \"length\";\n    },\n    getOwnPropertyDescriptor(target, index) {\n        const { context, objectId, heads } = target;\n        if (index === \"length\")\n            return { writable: true, value: context.length(objectId, heads) };\n        if (index === _constants__WEBPACK_IMPORTED_MODULE_2__.OBJECT_ID)\n            return { configurable: false, enumerable: false, value: objectId };\n        index = parseListIndex(index);\n        const value = valueAt(target, index);\n        return { configurable: true, enumerable: true, value };\n    },\n    getPrototypeOf(target) {\n        return Object.getPrototypeOf(target);\n    },\n    ownKeys( /*target*/) {\n        const keys = [];\n        // uncommenting this causes assert.deepEqual() to fail when comparing to a pojo array\n        // but not uncommenting it causes for (i in list) {} to not enumerate values properly\n        //const {context, objectId, heads } = target\n        //for (let i = 0; i < target.context.length(objectId, heads); i++) { keys.push(i.toString()) }\n        keys.push(\"length\");\n        return keys;\n    },\n};\nconst TextHandler = Object.assign({}, ListHandler, {\n    get(target, index) {\n        const { context, objectId, heads } = target;\n        index = parseListIndex(index);\n        if (index === Symbol.hasInstance) {\n            return (instance) => {\n                return Array.isArray(instance);\n            };\n        }\n        if (index === Symbol.toStringTag) {\n            return target[Symbol.toStringTag];\n        }\n        if (index === _constants__WEBPACK_IMPORTED_MODULE_2__.OBJECT_ID)\n            return objectId;\n        if (index === _constants__WEBPACK_IMPORTED_MODULE_2__.IS_PROXY)\n            return true;\n        if (index === _constants__WEBPACK_IMPORTED_MODULE_2__.TRACE)\n            return target.trace;\n        if (index === _constants__WEBPACK_IMPORTED_MODULE_2__.STATE)\n            return { handle: context };\n        if (index === \"length\")\n            return context.length(objectId, heads);\n        if (typeof index === \"number\") {\n            return valueAt(target, index);\n        }\n        else {\n            return textMethods(target)[index] || listMethods(target)[index];\n        }\n    },\n    getPrototypeOf( /*target*/) {\n        return Object.getPrototypeOf(new _text__WEBPACK_IMPORTED_MODULE_0__.Text());\n    },\n});\nfunction mapProxy(context, objectId, textV2, path, readonly, heads) {\n    const target = {\n        context,\n        objectId,\n        path: path || [],\n        readonly: !!readonly,\n        frozen: false,\n        heads,\n        cache: {},\n        textV2,\n    };\n    const proxied = {};\n    Object.assign(proxied, target);\n    const result = new Proxy(proxied, MapHandler);\n    // conversion through unknown is necessary because the types are so different\n    return result;\n}\nfunction listProxy(context, objectId, textV2, path, readonly, heads) {\n    const target = {\n        context,\n        objectId,\n        path: path || [],\n        readonly: !!readonly,\n        frozen: false,\n        heads,\n        cache: {},\n        textV2,\n    };\n    const proxied = [];\n    Object.assign(proxied, target);\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    return new Proxy(proxied, ListHandler);\n}\nfunction textProxy(context, objectId, path, readonly, heads) {\n    const target = {\n        context,\n        objectId,\n        path: path || [],\n        readonly: !!readonly,\n        frozen: false,\n        heads,\n        cache: {},\n        textV2: false,\n    };\n    const proxied = {};\n    Object.assign(proxied, target);\n    return new Proxy(proxied, TextHandler);\n}\nfunction rootProxy(context, textV2, readonly) {\n    /* eslint-disable-next-line */\n    return mapProxy(context, \"_root\", textV2, [], !!readonly);\n}\nfunction listMethods(target) {\n    const { context, objectId, path, readonly, frozen, heads, textV2 } = target;\n    const methods = {\n        deleteAt(index, numDelete) {\n            if (typeof numDelete === \"number\") {\n                context.splice(objectId, index, numDelete);\n            }\n            else {\n                context.delete(objectId, index);\n            }\n            return this;\n        },\n        fill(val, start, end) {\n            const [value, datatype] = import_value(val, textV2);\n            const length = context.length(objectId);\n            start = parseListIndex(start || 0);\n            end = parseListIndex(end || length);\n            for (let i = start; i < Math.min(end, length); i++) {\n                if (datatype === \"list\" || datatype === \"map\") {\n                    context.putObject(objectId, i, value);\n                }\n                else if (datatype === \"text\") {\n                    if (textV2) {\n                        assertString(value);\n                        context.putObject(objectId, i, value);\n                    }\n                    else {\n                        assertText(value);\n                        const text = context.putObject(objectId, i, \"\");\n                        const proxyText = textProxy(context, text, [...path, i], readonly);\n                        for (let i = 0; i < value.length; i++) {\n                            proxyText[i] = value.get(i);\n                        }\n                    }\n                }\n                else {\n                    context.put(objectId, i, value, datatype);\n                }\n            }\n            return this;\n        },\n        indexOf(o, start = 0) {\n            const length = context.length(objectId);\n            for (let i = start; i < length; i++) {\n                const value = context.getWithType(objectId, i, heads);\n                if (value && (value[1] === o[_constants__WEBPACK_IMPORTED_MODULE_2__.OBJECT_ID] || value[1] === o)) {\n                    return i;\n                }\n            }\n            return -1;\n        },\n        insertAt(index, ...values) {\n            this.splice(index, 0, ...values);\n            return this;\n        },\n        pop() {\n            const length = context.length(objectId);\n            if (length == 0) {\n                return undefined;\n            }\n            const last = valueAt(target, length - 1);\n            context.delete(objectId, length - 1);\n            return last;\n        },\n        push(...values) {\n            const len = context.length(objectId);\n            this.splice(len, 0, ...values);\n            return context.length(objectId);\n        },\n        shift() {\n            if (context.length(objectId) == 0)\n                return;\n            const first = valueAt(target, 0);\n            context.delete(objectId, 0);\n            return first;\n        },\n        splice(index, del, ...vals) {\n            index = parseListIndex(index);\n            del = parseListIndex(del);\n            for (const val of vals) {\n                if (val && val[_constants__WEBPACK_IMPORTED_MODULE_2__.OBJECT_ID]) {\n                    throw new RangeError(\"Cannot create a reference to an existing document object\");\n                }\n            }\n            if (frozen) {\n                throw new RangeError(\"Attempting to use an outdated Automerge document\");\n            }\n            if (readonly) {\n                throw new RangeError(\"Sequence object cannot be modified outside of a change block\");\n            }\n            const result = [];\n            for (let i = 0; i < del; i++) {\n                const value = valueAt(target, index);\n                if (value !== undefined) {\n                    result.push(value);\n                }\n                context.delete(objectId, index);\n            }\n            const values = vals.map(val => import_value(val, textV2));\n            for (const [value, datatype] of values) {\n                switch (datatype) {\n                    case \"list\": {\n                        const list = context.insertObject(objectId, index, []);\n                        const proxyList = listProxy(context, list, textV2, [...path, index], readonly);\n                        proxyList.splice(0, 0, ...value);\n                        break;\n                    }\n                    case \"text\": {\n                        if (textV2) {\n                            assertString(value);\n                            context.insertObject(objectId, index, value);\n                        }\n                        else {\n                            const text = context.insertObject(objectId, index, \"\");\n                            const proxyText = textProxy(context, text, [...path, index], readonly);\n                            proxyText.splice(0, 0, ...value);\n                        }\n                        break;\n                    }\n                    case \"map\": {\n                        const map = context.insertObject(objectId, index, {});\n                        const proxyMap = mapProxy(context, map, textV2, [...path, index], readonly);\n                        for (const key in value) {\n                            proxyMap[key] = value[key];\n                        }\n                        break;\n                    }\n                    default:\n                        context.insert(objectId, index, value, datatype);\n                }\n                index += 1;\n            }\n            return result;\n        },\n        unshift(...values) {\n            this.splice(0, 0, ...values);\n            return context.length(objectId);\n        },\n        entries() {\n            const i = 0;\n            const iterator = {\n                next: () => {\n                    const value = valueAt(target, i);\n                    if (value === undefined) {\n                        return { value: undefined, done: true };\n                    }\n                    else {\n                        return { value: [i, value], done: false };\n                    }\n                },\n            };\n            return iterator;\n        },\n        keys() {\n            let i = 0;\n            const len = context.length(objectId, heads);\n            const iterator = {\n                next: () => {\n                    let value = undefined;\n                    if (i < len) {\n                        value = i;\n                        i++;\n                    }\n                    return { value, done: true };\n                },\n            };\n            return iterator;\n        },\n        values() {\n            const i = 0;\n            const iterator = {\n                next: () => {\n                    const value = valueAt(target, i);\n                    if (value === undefined) {\n                        return { value: undefined, done: true };\n                    }\n                    else {\n                        return { value, done: false };\n                    }\n                },\n            };\n            return iterator;\n        },\n        toArray() {\n            const list = [];\n            let value;\n            do {\n                value = valueAt(target, list.length);\n                if (value !== undefined) {\n                    list.push(value);\n                }\n            } while (value !== undefined);\n            return list;\n        },\n        map(f) {\n            return this.toArray().map(f);\n        },\n        toString() {\n            return this.toArray().toString();\n        },\n        toLocaleString() {\n            return this.toArray().toLocaleString();\n        },\n        forEach(f) {\n            return this.toArray().forEach(f);\n        },\n        // todo: real concat function is different\n        concat(other) {\n            return this.toArray().concat(other);\n        },\n        every(f) {\n            return this.toArray().every(f);\n        },\n        filter(f) {\n            return this.toArray().filter(f);\n        },\n        find(f) {\n            let index = 0;\n            for (const v of this) {\n                if (f(v, index)) {\n                    return v;\n                }\n                index += 1;\n            }\n        },\n        findIndex(f) {\n            let index = 0;\n            for (const v of this) {\n                if (f(v, index)) {\n                    return index;\n                }\n                index += 1;\n            }\n            return -1;\n        },\n        includes(elem) {\n            return this.find(e => e === elem) !== undefined;\n        },\n        join(sep) {\n            return this.toArray().join(sep);\n        },\n        reduce(f, initialValue) {\n            return this.toArray().reduce(f, initialValue);\n        },\n        reduceRight(f, initialValue) {\n            return this.toArray().reduceRight(f, initialValue);\n        },\n        lastIndexOf(search, fromIndex = +Infinity) {\n            // this can be faster\n            return this.toArray().lastIndexOf(search, fromIndex);\n        },\n        slice(index, num) {\n            return this.toArray().slice(index, num);\n        },\n        some(f) {\n            let index = 0;\n            for (const v of this) {\n                if (f(v, index)) {\n                    return true;\n                }\n                index += 1;\n            }\n            return false;\n        },\n        [Symbol.iterator]: function* () {\n            let i = 0;\n            let value = valueAt(target, i);\n            while (value !== undefined) {\n                yield value;\n                i += 1;\n                value = valueAt(target, i);\n            }\n        },\n    };\n    return methods;\n}\nfunction textMethods(target) {\n    const { context, objectId, heads } = target;\n    const methods = {\n        set(index, value) {\n            return (this[index] = value);\n        },\n        get(index) {\n            return this[index];\n        },\n        toString() {\n            return context.text(objectId, heads).replace(//g, \"\");\n        },\n        toSpans() {\n            const spans = [];\n            let chars = \"\";\n            const length = context.length(objectId);\n            for (let i = 0; i < length; i++) {\n                const value = this[i];\n                if (typeof value === \"string\") {\n                    chars += value;\n                }\n                else {\n                    if (chars.length > 0) {\n                        spans.push(chars);\n                        chars = \"\";\n                    }\n                    spans.push(value);\n                }\n            }\n            if (chars.length > 0) {\n                spans.push(chars);\n            }\n            return spans;\n        },\n        toJSON() {\n            return this.toString();\n        },\n        indexOf(o, start = 0) {\n            const text = context.text(objectId);\n            return text.indexOf(o, start);\n        },\n    };\n    return methods;\n}\nfunction assertText(value) {\n    if (!(value instanceof _text__WEBPACK_IMPORTED_MODULE_0__.Text)) {\n        throw new Error(\"value was not a Text instance\");\n    }\n}\nfunction assertString(value) {\n    if (typeof value !== \"string\") {\n        throw new Error(\"value was not a string\");\n    }\n}\n\n\n//# sourceURL=webpack://experiments/./node_modules/@automerge/automerge/dist/mjs/proxies.js?");

/***/ }),

/***/ "./node_modules/@automerge/automerge/dist/mjs/raw_string.js":
/*!******************************************************************!*\
  !*** ./node_modules/@automerge/automerge/dist/mjs/raw_string.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RawString: () => (/* binding */ RawString)\n/* harmony export */ });\nclass RawString {\n    constructor(val) {\n        this.val = val;\n    }\n}\n\n\n//# sourceURL=webpack://experiments/./node_modules/@automerge/automerge/dist/mjs/raw_string.js?");

/***/ }),

/***/ "./node_modules/@automerge/automerge/dist/mjs/stable.js":
/*!**************************************************************!*\
  !*** ./node_modules/@automerge/automerge/dist/mjs/stable.js ***!
  \**************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Counter: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_3__.Counter),\n/* harmony export */   Float64: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_3__.Float64),\n/* harmony export */   Int: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_3__.Int),\n/* harmony export */   Text: () => (/* reexport safe */ _text__WEBPACK_IMPORTED_MODULE_4__.Text),\n/* harmony export */   Uint: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_3__.Uint),\n/* harmony export */   applyChanges: () => (/* binding */ applyChanges),\n/* harmony export */   change: () => (/* binding */ change),\n/* harmony export */   clone: () => (/* binding */ clone),\n/* harmony export */   decodeChange: () => (/* binding */ decodeChange),\n/* harmony export */   decodeSyncMessage: () => (/* binding */ decodeSyncMessage),\n/* harmony export */   decodeSyncState: () => (/* binding */ decodeSyncState),\n/* harmony export */   dump: () => (/* binding */ dump),\n/* harmony export */   emptyChange: () => (/* binding */ emptyChange),\n/* harmony export */   encodeChange: () => (/* binding */ encodeChange),\n/* harmony export */   encodeSyncMessage: () => (/* binding */ encodeSyncMessage),\n/* harmony export */   encodeSyncState: () => (/* binding */ encodeSyncState),\n/* harmony export */   equals: () => (/* binding */ equals),\n/* harmony export */   free: () => (/* binding */ free),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   generateSyncMessage: () => (/* binding */ generateSyncMessage),\n/* harmony export */   getActorId: () => (/* binding */ getActorId),\n/* harmony export */   getAllChanges: () => (/* binding */ getAllChanges),\n/* harmony export */   getBackend: () => (/* binding */ getBackend),\n/* harmony export */   getChanges: () => (/* binding */ getChanges),\n/* harmony export */   getConflicts: () => (/* binding */ getConflicts),\n/* harmony export */   getHeads: () => (/* binding */ getHeads),\n/* harmony export */   getHistory: () => (/* binding */ getHistory),\n/* harmony export */   getLastLocalChange: () => (/* binding */ getLastLocalChange),\n/* harmony export */   getMissingDeps: () => (/* binding */ getMissingDeps),\n/* harmony export */   getObjectId: () => (/* binding */ getObjectId),\n/* harmony export */   init: () => (/* binding */ init),\n/* harmony export */   initSyncState: () => (/* binding */ initSyncState),\n/* harmony export */   isAutomerge: () => (/* binding */ isAutomerge),\n/* harmony export */   load: () => (/* binding */ load),\n/* harmony export */   loadIncremental: () => (/* binding */ loadIncremental),\n/* harmony export */   merge: () => (/* binding */ merge),\n/* harmony export */   receiveSyncMessage: () => (/* binding */ receiveSyncMessage),\n/* harmony export */   save: () => (/* binding */ save),\n/* harmony export */   saveIncremental: () => (/* binding */ saveIncremental),\n/* harmony export */   toJS: () => (/* binding */ toJS),\n/* harmony export */   use: () => (/* binding */ use),\n/* harmony export */   uuid: () => (/* reexport safe */ _uuid__WEBPACK_IMPORTED_MODULE_0__.uuid),\n/* harmony export */   view: () => (/* binding */ view)\n/* harmony export */ });\n/* harmony import */ var _uuid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./uuid */ \"./node_modules/@automerge/automerge/dist/mjs/uuid.js\");\n/* harmony import */ var _proxies__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./proxies */ \"./node_modules/@automerge/automerge/dist/mjs/proxies.js\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants */ \"./node_modules/@automerge/automerge/dist/mjs/constants.js\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./types */ \"./node_modules/@automerge/automerge/dist/mjs/types.js\");\n/* harmony import */ var _text__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./text */ \"./node_modules/@automerge/automerge/dist/mjs/text.js\");\n/* harmony import */ var _low_level__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./low_level */ \"./node_modules/@automerge/automerge/dist/mjs/low_level.js\");\n/* harmony import */ var _raw_string__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./raw_string */ \"./node_modules/@automerge/automerge/dist/mjs/raw_string.js\");\n/* harmony import */ var _internal_state__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./internal_state */ \"./node_modules/@automerge/automerge/dist/mjs/internal_state.js\");\n/* harmony import */ var _conflicts__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./conflicts */ \"./node_modules/@automerge/automerge/dist/mjs/conflicts.js\");\n/* harmony import */ var _automerge_automerge_wasm__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @automerge/automerge-wasm */ \"./node_modules/@automerge/automerge-wasm/bundler/automerge_wasm.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_automerge_automerge_wasm__WEBPACK_IMPORTED_MODULE_9__]);\n_automerge_automerge_wasm__WEBPACK_IMPORTED_MODULE_9__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\nvar __rest = (undefined && undefined.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\n/** @hidden **/\n\n\n\n\n\n\n\nconst SyncStateSymbol = Symbol(\"_syncstate\");\n\n\n\n\n/** @hidden **/\nfunction use(api) {\n    (0,_low_level__WEBPACK_IMPORTED_MODULE_5__.UseApi)(api);\n}\n\nuse(_automerge_automerge_wasm__WEBPACK_IMPORTED_MODULE_9__);\n/** @hidden */\nfunction getBackend(doc) {\n    return (0,_internal_state__WEBPACK_IMPORTED_MODULE_7__._state)(doc).handle;\n}\nfunction importOpts(_actor) {\n    if (typeof _actor === \"object\") {\n        return _actor;\n    }\n    else {\n        return { actor: _actor };\n    }\n}\n/**\n * Create a new automerge document\n *\n * @typeParam T - The type of value contained in the document. This will be the\n *     type that is passed to the change closure in {@link change}\n * @param _opts - Either an actorId or an {@link InitOptions} (which may\n *     contain an actorId). If this is null the document will be initialised with a\n *     random actor ID\n */\nfunction init(_opts) {\n    const opts = importOpts(_opts);\n    const freeze = !!opts.freeze;\n    const patchCallback = opts.patchCallback;\n    const handle = _low_level__WEBPACK_IMPORTED_MODULE_5__.ApiHandler.create(opts.enableTextV2 || false, opts.actor);\n    handle.enablePatches(true);\n    handle.enableFreeze(!!opts.freeze);\n    handle.registerDatatype(\"counter\", (n) => new _types__WEBPACK_IMPORTED_MODULE_3__.Counter(n));\n    const textV2 = opts.enableTextV2 || false;\n    if (textV2) {\n        handle.registerDatatype(\"str\", (n) => new _raw_string__WEBPACK_IMPORTED_MODULE_6__.RawString(n));\n    }\n    else {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        handle.registerDatatype(\"text\", (n) => new _text__WEBPACK_IMPORTED_MODULE_4__.Text(n));\n    }\n    const doc = handle.materialize(\"/\", undefined, {\n        handle,\n        heads: undefined,\n        freeze,\n        patchCallback,\n        textV2,\n    });\n    return doc;\n}\n/**\n * Make an immutable view of an automerge document as at `heads`\n *\n * @remarks\n * The document returned from this function cannot be passed to {@link change}.\n * This is because it shares the same underlying memory as `doc`, but it is\n * consequently a very cheap copy.\n *\n * Note that this function will throw an error if any of the hashes in `heads`\n * are not in the document.\n *\n * @typeParam T - The type of the value contained in the document\n * @param doc - The document to create a view of\n * @param heads - The hashes of the heads to create a view at\n */\nfunction view(doc, heads) {\n    const state = (0,_internal_state__WEBPACK_IMPORTED_MODULE_7__._state)(doc);\n    const handle = state.handle;\n    return state.handle.materialize(\"/\", heads, Object.assign(Object.assign({}, state), { handle,\n        heads }));\n}\n/**\n * Make a full writable copy of an automerge document\n *\n * @remarks\n * Unlike {@link view} this function makes a full copy of the memory backing\n * the document and can thus be passed to {@link change}. It also generates a\n * new actor ID so that changes made in the new document do not create duplicate\n * sequence numbers with respect to the old document. If you need control over\n * the actor ID which is generated you can pass the actor ID as the second\n * argument\n *\n * @typeParam T - The type of the value contained in the document\n * @param doc - The document to clone\n * @param _opts - Either an actor ID to use for the new doc or an {@link InitOptions}\n */\nfunction clone(doc, _opts) {\n    const state = (0,_internal_state__WEBPACK_IMPORTED_MODULE_7__._state)(doc);\n    const heads = state.heads;\n    const opts = importOpts(_opts);\n    const handle = state.handle.fork(opts.actor, heads);\n    // `change` uses the presence of state.heads to determine if we are in a view\n    // set it to undefined to indicate that this is a full fat document\n    const { heads: _oldHeads } = state, stateSansHeads = __rest(state, [\"heads\"]);\n    stateSansHeads.patchCallback = opts.patchCallback;\n    return handle.applyPatches(doc, Object.assign(Object.assign({}, stateSansHeads), { handle }));\n}\n/** Explicity free the memory backing a document. Note that this is note\n * necessary in environments which support\n * [`FinalizationRegistry`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry)\n */\nfunction free(doc) {\n    return (0,_internal_state__WEBPACK_IMPORTED_MODULE_7__._state)(doc).handle.free();\n}\n/**\n * Create an automerge document from a POJO\n *\n * @param initialState - The initial state which will be copied into the document\n * @typeParam T - The type of the value passed to `from` _and_ the type the resulting document will contain\n * @typeParam actor - The actor ID of the resulting document, if this is null a random actor ID will be used\n *\n * @example\n * ```\n * const doc = automerge.from({\n *     tasks: [\n *         {description: \"feed dogs\", done: false}\n *     ]\n * })\n * ```\n */\nfunction from(initialState, _opts) {\n    return change(init(_opts), d => Object.assign(d, initialState));\n}\n/**\n * Update the contents of an automerge document\n * @typeParam T - The type of the value contained in the document\n * @param doc - The document to update\n * @param options - Either a message, an {@link ChangeOptions}, or a {@link ChangeFn}\n * @param callback - A `ChangeFn` to be used if `options` was a `string`\n *\n * Note that if the second argument is a function it will be used as the `ChangeFn` regardless of what the third argument is.\n *\n * @example A simple change\n * ```\n * let doc1 = automerge.init()\n * doc1 = automerge.change(doc1, d => {\n *     d.key = \"value\"\n * })\n * assert.equal(doc1.key, \"value\")\n * ```\n *\n * @example A change with a message\n *\n * ```\n * doc1 = automerge.change(doc1, \"add another value\", d => {\n *     d.key2 = \"value2\"\n * })\n * ```\n *\n * @example A change with a message and a timestamp\n *\n * ```\n * doc1 = automerge.change(doc1, {message: \"add another value\", time: 1640995200}, d => {\n *     d.key2 = \"value2\"\n * })\n * ```\n *\n * @example responding to a patch callback\n * ```\n * let patchedPath\n * let patchCallback = patch => {\n *    patchedPath = patch.path\n * }\n * doc1 = automerge.change(doc1, {message, \"add another value\", time: 1640995200, patchCallback}, d => {\n *     d.key2 = \"value2\"\n * })\n * assert.equal(patchedPath, [\"key2\"])\n * ```\n */\nfunction change(doc, options, callback) {\n    if (typeof options === \"function\") {\n        return _change(doc, {}, options);\n    }\n    else if (typeof callback === \"function\") {\n        if (typeof options === \"string\") {\n            options = { message: options };\n        }\n        return _change(doc, options, callback);\n    }\n    else {\n        throw RangeError(\"Invalid args for change\");\n    }\n}\nfunction progressDocument(doc, heads, callback) {\n    if (heads == null) {\n        return doc;\n    }\n    const state = (0,_internal_state__WEBPACK_IMPORTED_MODULE_7__._state)(doc);\n    const nextState = Object.assign(Object.assign({}, state), { heads: undefined });\n    const nextDoc = state.handle.applyPatches(doc, nextState, callback);\n    state.heads = heads;\n    return nextDoc;\n}\nfunction _change(doc, options, callback) {\n    if (typeof callback !== \"function\") {\n        throw new RangeError(\"invalid change function\");\n    }\n    const state = (0,_internal_state__WEBPACK_IMPORTED_MODULE_7__._state)(doc);\n    if (doc === undefined || state === undefined) {\n        throw new RangeError(\"must be the document root\");\n    }\n    if (state.heads) {\n        throw new RangeError(\"Attempting to change an outdated document.  Use Automerge.clone() if you wish to make a writable copy.\");\n    }\n    if ((0,_internal_state__WEBPACK_IMPORTED_MODULE_7__._is_proxy)(doc)) {\n        throw new RangeError(\"Calls to Automerge.change cannot be nested\");\n    }\n    const heads = state.handle.getHeads();\n    try {\n        state.heads = heads;\n        const root = (0,_proxies__WEBPACK_IMPORTED_MODULE_1__.rootProxy)(state.handle, state.textV2);\n        callback(root);\n        if (state.handle.pendingOps() === 0) {\n            state.heads = undefined;\n            return doc;\n        }\n        else {\n            state.handle.commit(options.message, options.time);\n            return progressDocument(doc, heads, options.patchCallback || state.patchCallback);\n        }\n    }\n    catch (e) {\n        state.heads = undefined;\n        state.handle.rollback();\n        throw e;\n    }\n}\n/**\n * Make a change to a document which does not modify the document\n *\n * @param doc - The doc to add the empty change to\n * @param options - Either a message or a {@link ChangeOptions} for the new change\n *\n * Why would you want to do this? One reason might be that you have merged\n * changes from some other peers and you want to generate a change which\n * depends on those merged changes so that you can sign the new change with all\n * of the merged changes as part of the new change.\n */\nfunction emptyChange(doc, options) {\n    if (options === undefined) {\n        options = {};\n    }\n    if (typeof options === \"string\") {\n        options = { message: options };\n    }\n    const state = (0,_internal_state__WEBPACK_IMPORTED_MODULE_7__._state)(doc);\n    if (state.heads) {\n        throw new RangeError(\"Attempting to change an outdated document.  Use Automerge.clone() if you wish to make a writable copy.\");\n    }\n    if ((0,_internal_state__WEBPACK_IMPORTED_MODULE_7__._is_proxy)(doc)) {\n        throw new RangeError(\"Calls to Automerge.change cannot be nested\");\n    }\n    const heads = state.handle.getHeads();\n    state.handle.emptyChange(options.message, options.time);\n    return progressDocument(doc, heads);\n}\n/**\n * Load an automerge document from a compressed document produce by {@link save}\n *\n * @typeParam T - The type of the value which is contained in the document.\n *                Note that no validation is done to make sure this type is in\n *                fact the type of the contained value so be a bit careful\n * @param data  - The compressed document\n * @param _opts - Either an actor ID or some {@link InitOptions}, if the actor\n *                ID is null a random actor ID will be created\n *\n * Note that `load` will throw an error if passed incomplete content (for\n * example if you are receiving content over the network and don't know if you\n * have the complete document yet). If you need to handle incomplete content use\n * {@link init} followed by {@link loadIncremental}.\n */\nfunction load(data, _opts) {\n    const opts = importOpts(_opts);\n    const actor = opts.actor;\n    const patchCallback = opts.patchCallback;\n    const handle = _low_level__WEBPACK_IMPORTED_MODULE_5__.ApiHandler.load(data, opts.enableTextV2 || false, actor);\n    handle.enablePatches(true);\n    handle.enableFreeze(!!opts.freeze);\n    handle.registerDatatype(\"counter\", (n) => new _types__WEBPACK_IMPORTED_MODULE_3__.Counter(n));\n    const textV2 = opts.enableTextV2 || false;\n    if (textV2) {\n        handle.registerDatatype(\"str\", (n) => new _raw_string__WEBPACK_IMPORTED_MODULE_6__.RawString(n));\n    }\n    else {\n        handle.registerDatatype(\"text\", (n) => new _text__WEBPACK_IMPORTED_MODULE_4__.Text(n));\n    }\n    const doc = handle.materialize(\"/\", undefined, {\n        handle,\n        heads: undefined,\n        patchCallback,\n        textV2,\n    });\n    return doc;\n}\n/**\n * Load changes produced by {@link saveIncremental}, or partial changes\n *\n * @typeParam T - The type of the value which is contained in the document.\n *                Note that no validation is done to make sure this type is in\n *                fact the type of the contained value so be a bit careful\n * @param data  - The compressedchanges\n * @param opts  - an {@link ApplyOptions}\n *\n * This function is useful when staying up to date with a connected peer.\n * Perhaps the other end sent you a full compresed document which you loaded\n * with {@link load} and they're sending you the result of\n * {@link getLastLocalChange} every time they make a change.\n *\n * Note that this function will succesfully load the results of {@link save} as\n * well as {@link getLastLocalChange} or any other incremental change.\n */\nfunction loadIncremental(doc, data, opts) {\n    if (!opts) {\n        opts = {};\n    }\n    const state = (0,_internal_state__WEBPACK_IMPORTED_MODULE_7__._state)(doc);\n    if (state.heads) {\n        throw new RangeError(\"Attempting to change an out of date document - set at: \" + (0,_internal_state__WEBPACK_IMPORTED_MODULE_7__._trace)(doc));\n    }\n    if ((0,_internal_state__WEBPACK_IMPORTED_MODULE_7__._is_proxy)(doc)) {\n        throw new RangeError(\"Calls to Automerge.change cannot be nested\");\n    }\n    const heads = state.handle.getHeads();\n    state.handle.loadIncremental(data);\n    return progressDocument(doc, heads, opts.patchCallback || state.patchCallback);\n}\n/**\n * Create binary save data to be appended to a save file or fed into {@link loadIncremental}\n *\n * @typeParam T - The type of the value which is contained in the document.\n *                Note that no validation is done to make sure this type is in\n *                fact the type of the contained value so be a bit careful\n *\n * This function is useful for incrementally saving state.  The data can be appended to a\n * automerge save file, or passed to a document replicating its state.\n *\n */\nfunction saveIncremental(doc) {\n    const state = (0,_internal_state__WEBPACK_IMPORTED_MODULE_7__._state)(doc);\n    if (state.heads) {\n        throw new RangeError(\"Attempting to change an out of date document - set at: \" + (0,_internal_state__WEBPACK_IMPORTED_MODULE_7__._trace)(doc));\n    }\n    if ((0,_internal_state__WEBPACK_IMPORTED_MODULE_7__._is_proxy)(doc)) {\n        throw new RangeError(\"Calls to Automerge.change cannot be nested\");\n    }\n    return state.handle.saveIncremental();\n}\n/**\n * Export the contents of a document to a compressed format\n *\n * @param doc - The doc to save\n *\n * The returned bytes can be passed to {@link load} or {@link loadIncremental}\n */\nfunction save(doc) {\n    return (0,_internal_state__WEBPACK_IMPORTED_MODULE_7__._state)(doc).handle.save();\n}\n/**\n * Merge `local` into `remote`\n * @typeParam T - The type of values contained in each document\n * @param local - The document to merge changes into\n * @param remote - The document to merge changes from\n *\n * @returns - The merged document\n *\n * Often when you are merging documents you will also need to clone them. Both\n * arguments to `merge` are frozen after the call so you can no longer call\n * mutating methods (such as {@link change}) on them. The symtom of this will be\n * an error which says \"Attempting to change an out of date document\". To\n * overcome this call {@link clone} on the argument before passing it to {@link\n * merge}.\n */\nfunction merge(local, remote) {\n    const localState = (0,_internal_state__WEBPACK_IMPORTED_MODULE_7__._state)(local);\n    if (localState.heads) {\n        throw new RangeError(\"Attempting to change an out of date document - set at: \" + (0,_internal_state__WEBPACK_IMPORTED_MODULE_7__._trace)(local));\n    }\n    const heads = localState.handle.getHeads();\n    const remoteState = (0,_internal_state__WEBPACK_IMPORTED_MODULE_7__._state)(remote);\n    const changes = localState.handle.getChangesAdded(remoteState.handle);\n    localState.handle.applyChanges(changes);\n    return progressDocument(local, heads, localState.patchCallback);\n}\n/**\n * Get the actor ID associated with the document\n */\nfunction getActorId(doc) {\n    const state = (0,_internal_state__WEBPACK_IMPORTED_MODULE_7__._state)(doc);\n    return state.handle.getActorId();\n}\n/**\n * Get the conflicts associated with a property\n *\n * The values of properties in a map in automerge can be conflicted if there\n * are concurrent \"put\" operations to the same key. Automerge chooses one value\n * arbitrarily (but deterministically, any two nodes who have the same set of\n * changes will choose the same value) from the set of conflicting values to\n * present as the value of the key.\n *\n * Sometimes you may want to examine these conflicts, in this case you can use\n * {@link getConflicts} to get the conflicts for the key.\n *\n * @example\n * ```\n * import * as automerge from \"@automerge/automerge\"\n *\n * type Profile = {\n *     pets: Array<{name: string, type: string}>\n * }\n *\n * let doc1 = automerge.init<Profile>(\"aaaa\")\n * doc1 = automerge.change(doc1, d => {\n *     d.pets = [{name: \"Lassie\", type: \"dog\"}]\n * })\n * let doc2 = automerge.init<Profile>(\"bbbb\")\n * doc2 = automerge.merge(doc2, automerge.clone(doc1))\n *\n * doc2 = automerge.change(doc2, d => {\n *     d.pets[0].name = \"Beethoven\"\n * })\n *\n * doc1 = automerge.change(doc1, d => {\n *     d.pets[0].name = \"Babe\"\n * })\n *\n * const doc3 = automerge.merge(doc1, doc2)\n *\n * // Note that here we pass `doc3.pets`, not `doc3`\n * let conflicts = automerge.getConflicts(doc3.pets[0], \"name\")\n *\n * // The two conflicting values are the keys of the conflicts object\n * assert.deepEqual(Object.values(conflicts), [\"Babe\", Beethoven\"])\n * ```\n */\nfunction getConflicts(doc, prop) {\n    const state = (0,_internal_state__WEBPACK_IMPORTED_MODULE_7__._state)(doc, false);\n    if (state.textV2) {\n        throw new Error(\"use unstable.getConflicts for an unstable document\");\n    }\n    const objectId = (0,_internal_state__WEBPACK_IMPORTED_MODULE_7__._obj)(doc);\n    if (objectId != null) {\n        return (0,_conflicts__WEBPACK_IMPORTED_MODULE_8__.stableConflictAt)(state.handle, objectId, prop);\n    }\n    else {\n        return undefined;\n    }\n}\n/**\n * Get the binary representation of the last change which was made to this doc\n *\n * This is most useful when staying in sync with other peers, every time you\n * make a change locally via {@link change} you immediately call {@link\n * getLastLocalChange} and send the result over the network to other peers.\n */\nfunction getLastLocalChange(doc) {\n    const state = (0,_internal_state__WEBPACK_IMPORTED_MODULE_7__._state)(doc);\n    return state.handle.getLastLocalChange() || undefined;\n}\n/**\n * Return the object ID of an arbitrary javascript value\n *\n * This is useful to determine if something is actually an automerge document,\n * if `doc` is not an automerge document this will return null.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction getObjectId(doc, prop) {\n    if (prop) {\n        const state = (0,_internal_state__WEBPACK_IMPORTED_MODULE_7__._state)(doc, false);\n        const objectId = (0,_internal_state__WEBPACK_IMPORTED_MODULE_7__._obj)(doc);\n        if (!state || !objectId) {\n            return null;\n        }\n        return state.handle.get(objectId, prop);\n    }\n    else {\n        return (0,_internal_state__WEBPACK_IMPORTED_MODULE_7__._obj)(doc);\n    }\n}\n/**\n * Get the changes which are in `newState` but not in `oldState`. The returned\n * changes can be loaded in `oldState` via {@link applyChanges}.\n *\n * Note that this will crash if there are changes in `oldState` which are not in `newState`.\n */\nfunction getChanges(oldState, newState) {\n    const n = (0,_internal_state__WEBPACK_IMPORTED_MODULE_7__._state)(newState);\n    return n.handle.getChanges(getHeads(oldState));\n}\n/**\n * Get all the changes in a document\n *\n * This is different to {@link save} because the output is an array of changes\n * which can be individually applied via {@link applyChanges}`\n *\n */\nfunction getAllChanges(doc) {\n    const state = (0,_internal_state__WEBPACK_IMPORTED_MODULE_7__._state)(doc);\n    return state.handle.getChanges([]);\n}\n/**\n * Apply changes received from another document\n *\n * `doc` will be updated to reflect the `changes`. If there are changes which\n * we do not have dependencies for yet those will be stored in the document and\n * applied when the depended on changes arrive.\n *\n * You can use the {@link ApplyOptions} to pass a patchcallback which will be\n * informed of any changes which occur as a result of applying the changes\n *\n */\nfunction applyChanges(doc, changes, opts) {\n    const state = (0,_internal_state__WEBPACK_IMPORTED_MODULE_7__._state)(doc);\n    if (!opts) {\n        opts = {};\n    }\n    if (state.heads) {\n        throw new RangeError(\"Attempting to change an outdated document.  Use Automerge.clone() if you wish to make a writable copy.\");\n    }\n    if ((0,_internal_state__WEBPACK_IMPORTED_MODULE_7__._is_proxy)(doc)) {\n        throw new RangeError(\"Calls to Automerge.change cannot be nested\");\n    }\n    const heads = state.handle.getHeads();\n    state.handle.applyChanges(changes);\n    state.heads = heads;\n    return [\n        progressDocument(doc, heads, opts.patchCallback || state.patchCallback),\n    ];\n}\n/** @hidden */\nfunction getHistory(doc) {\n    const textV2 = (0,_internal_state__WEBPACK_IMPORTED_MODULE_7__._state)(doc).textV2;\n    const history = getAllChanges(doc);\n    return history.map((change, index) => ({\n        get change() {\n            return decodeChange(change);\n        },\n        get snapshot() {\n            const [state] = applyChanges(init({ enableTextV2: textV2 }), history.slice(0, index + 1));\n            return state;\n        },\n    }));\n}\n/** @hidden */\n// FIXME : no tests\n// FIXME can we just use deep equals now?\nfunction equals(val1, val2) {\n    if (!isObject(val1) || !isObject(val2))\n        return val1 === val2;\n    const keys1 = Object.keys(val1).sort(), keys2 = Object.keys(val2).sort();\n    if (keys1.length !== keys2.length)\n        return false;\n    for (let i = 0; i < keys1.length; i++) {\n        if (keys1[i] !== keys2[i])\n            return false;\n        if (!equals(val1[keys1[i]], val2[keys2[i]]))\n            return false;\n    }\n    return true;\n}\n/**\n * encode a {@link SyncState} into binary to send over the network\n *\n * @group sync\n * */\nfunction encodeSyncState(state) {\n    const sync = _low_level__WEBPACK_IMPORTED_MODULE_5__.ApiHandler.importSyncState(state);\n    const result = _low_level__WEBPACK_IMPORTED_MODULE_5__.ApiHandler.encodeSyncState(sync);\n    sync.free();\n    return result;\n}\n/**\n * Decode some binary data into a {@link SyncState}\n *\n * @group sync\n */\nfunction decodeSyncState(state) {\n    const sync = _low_level__WEBPACK_IMPORTED_MODULE_5__.ApiHandler.decodeSyncState(state);\n    const result = _low_level__WEBPACK_IMPORTED_MODULE_5__.ApiHandler.exportSyncState(sync);\n    sync.free();\n    return result;\n}\n/**\n * Generate a sync message to send to the peer represented by `inState`\n * @param doc - The doc to generate messages about\n * @param inState - The {@link SyncState} representing the peer we are talking to\n *\n * @group sync\n *\n * @returns An array of `[newSyncState, syncMessage | null]` where\n * `newSyncState` should replace `inState` and `syncMessage` should be sent to\n * the peer if it is not null. If `syncMessage` is null then we are up to date.\n */\nfunction generateSyncMessage(doc, inState) {\n    const state = (0,_internal_state__WEBPACK_IMPORTED_MODULE_7__._state)(doc);\n    const syncState = _low_level__WEBPACK_IMPORTED_MODULE_5__.ApiHandler.importSyncState(inState);\n    const message = state.handle.generateSyncMessage(syncState);\n    const outState = _low_level__WEBPACK_IMPORTED_MODULE_5__.ApiHandler.exportSyncState(syncState);\n    return [outState, message];\n}\n/**\n * Update a document and our sync state on receiving a sync message\n *\n * @group sync\n *\n * @param doc     - The doc the sync message is about\n * @param inState - The {@link SyncState} for the peer we are communicating with\n * @param message - The message which was received\n * @param opts    - Any {@link ApplyOption}s, used for passing a\n *                  {@link PatchCallback} which will be informed of any changes\n *                  in `doc` which occur because of the received sync message.\n *\n * @returns An array of `[newDoc, newSyncState, syncMessage | null]` where\n * `newDoc` is the updated state of `doc`, `newSyncState` should replace\n * `inState` and `syncMessage` should be sent to the peer if it is not null. If\n * `syncMessage` is null then we are up to date.\n */\nfunction receiveSyncMessage(doc, inState, message, opts) {\n    const syncState = _low_level__WEBPACK_IMPORTED_MODULE_5__.ApiHandler.importSyncState(inState);\n    if (!opts) {\n        opts = {};\n    }\n    const state = (0,_internal_state__WEBPACK_IMPORTED_MODULE_7__._state)(doc);\n    if (state.heads) {\n        throw new RangeError(\"Attempting to change an outdated document.  Use Automerge.clone() if you wish to make a writable copy.\");\n    }\n    if ((0,_internal_state__WEBPACK_IMPORTED_MODULE_7__._is_proxy)(doc)) {\n        throw new RangeError(\"Calls to Automerge.change cannot be nested\");\n    }\n    const heads = state.handle.getHeads();\n    state.handle.receiveSyncMessage(syncState, message);\n    const outSyncState = _low_level__WEBPACK_IMPORTED_MODULE_5__.ApiHandler.exportSyncState(syncState);\n    return [\n        progressDocument(doc, heads, opts.patchCallback || state.patchCallback),\n        outSyncState,\n        null,\n    ];\n}\n/**\n * Create a new, blank {@link SyncState}\n *\n * When communicating with a peer for the first time use this to generate a new\n * {@link SyncState} for them\n *\n * @group sync\n */\nfunction initSyncState() {\n    return _low_level__WEBPACK_IMPORTED_MODULE_5__.ApiHandler.exportSyncState(_low_level__WEBPACK_IMPORTED_MODULE_5__.ApiHandler.initSyncState());\n}\n/** @hidden */\nfunction encodeChange(change) {\n    return _low_level__WEBPACK_IMPORTED_MODULE_5__.ApiHandler.encodeChange(change);\n}\n/** @hidden */\nfunction decodeChange(data) {\n    return _low_level__WEBPACK_IMPORTED_MODULE_5__.ApiHandler.decodeChange(data);\n}\n/** @hidden */\nfunction encodeSyncMessage(message) {\n    return _low_level__WEBPACK_IMPORTED_MODULE_5__.ApiHandler.encodeSyncMessage(message);\n}\n/** @hidden */\nfunction decodeSyncMessage(message) {\n    return _low_level__WEBPACK_IMPORTED_MODULE_5__.ApiHandler.decodeSyncMessage(message);\n}\n/**\n * Get any changes in `doc` which are not dependencies of `heads`\n */\nfunction getMissingDeps(doc, heads) {\n    const state = (0,_internal_state__WEBPACK_IMPORTED_MODULE_7__._state)(doc);\n    return state.handle.getMissingDeps(heads);\n}\n/**\n * Get the hashes of the heads of this document\n */\nfunction getHeads(doc) {\n    const state = (0,_internal_state__WEBPACK_IMPORTED_MODULE_7__._state)(doc);\n    return state.heads || state.handle.getHeads();\n}\n/** @hidden */\nfunction dump(doc) {\n    const state = (0,_internal_state__WEBPACK_IMPORTED_MODULE_7__._state)(doc);\n    state.handle.dump();\n}\n/** @hidden */\nfunction toJS(doc) {\n    const state = (0,_internal_state__WEBPACK_IMPORTED_MODULE_7__._state)(doc);\n    const enabled = state.handle.enableFreeze(false);\n    const result = state.handle.materialize();\n    state.handle.enableFreeze(enabled);\n    return result;\n}\nfunction isAutomerge(doc) {\n    if (typeof doc == \"object\" && doc !== null) {\n        return getObjectId(doc) === \"_root\" && !!Reflect.get(doc, _constants__WEBPACK_IMPORTED_MODULE_2__.STATE);\n    }\n    else {\n        return false;\n    }\n}\nfunction isObject(obj) {\n    return typeof obj === \"object\" && obj !== null;\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://experiments/./node_modules/@automerge/automerge/dist/mjs/stable.js?");

/***/ }),

/***/ "./node_modules/@automerge/automerge/dist/mjs/text.js":
/*!************************************************************!*\
  !*** ./node_modules/@automerge/automerge/dist/mjs/text.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Text: () => (/* binding */ Text)\n/* harmony export */ });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"./node_modules/@automerge/automerge/dist/mjs/constants.js\");\n\nclass Text {\n    constructor(text) {\n        if (typeof text === \"string\") {\n            this.elems = [...text];\n        }\n        else if (Array.isArray(text)) {\n            this.elems = text;\n        }\n        else if (text === undefined) {\n            this.elems = [];\n        }\n        else {\n            throw new TypeError(`Unsupported initial value for Text: ${text}`);\n        }\n        Reflect.defineProperty(this, _constants__WEBPACK_IMPORTED_MODULE_0__.TEXT, { value: true });\n    }\n    get length() {\n        return this.elems.length;\n    }\n    //eslint-disable-next-line @typescript-eslint/no-explicit-any\n    get(index) {\n        return this.elems[index];\n    }\n    /**\n     * Iterates over the text elements character by character, including any\n     * inline objects.\n     */\n    [Symbol.iterator]() {\n        const elems = this.elems;\n        let index = -1;\n        return {\n            next() {\n                index += 1;\n                if (index < elems.length) {\n                    return { done: false, value: elems[index] };\n                }\n                else {\n                    return { done: true };\n                }\n            },\n        };\n    }\n    /**\n     * Returns the content of the Text object as a simple string, ignoring any\n     * non-character elements.\n     */\n    toString() {\n        if (!this.str) {\n            // Concatting to a string is faster than creating an array and then\n            // .join()ing for small (<100KB) arrays.\n            // https://jsperf.com/join-vs-loop-w-type-test\n            this.str = \"\";\n            for (const elem of this.elems) {\n                if (typeof elem === \"string\")\n                    this.str += elem;\n                else\n                    this.str += \"\\uFFFC\";\n            }\n        }\n        return this.str;\n    }\n    /**\n     * Returns the content of the Text object as a sequence of strings,\n     * interleaved with non-character elements.\n     *\n     * For example, the value `['a', 'b', {x: 3}, 'c', 'd']` has spans:\n     * `=> ['ab', {x: 3}, 'cd']`\n     */\n    toSpans() {\n        if (!this.spans) {\n            this.spans = [];\n            let chars = \"\";\n            for (const elem of this.elems) {\n                if (typeof elem === \"string\") {\n                    chars += elem;\n                }\n                else {\n                    if (chars.length > 0) {\n                        this.spans.push(chars);\n                        chars = \"\";\n                    }\n                    this.spans.push(elem);\n                }\n            }\n            if (chars.length > 0) {\n                this.spans.push(chars);\n            }\n        }\n        return this.spans;\n    }\n    /**\n     * Returns the content of the Text object as a simple string, so that the\n     * JSON serialization of an Automerge document represents text nicely.\n     */\n    toJSON() {\n        return this.toString();\n    }\n    /**\n     * Updates the list item at position `index` to a new value `value`.\n     */\n    set(index, value) {\n        if (this[_constants__WEBPACK_IMPORTED_MODULE_0__.STATE]) {\n            throw new RangeError(\"object cannot be modified outside of a change block\");\n        }\n        this.elems[index] = value;\n    }\n    /**\n     * Inserts new list items `values` starting at position `index`.\n     */\n    insertAt(index, ...values) {\n        if (this[_constants__WEBPACK_IMPORTED_MODULE_0__.STATE]) {\n            throw new RangeError(\"object cannot be modified outside of a change block\");\n        }\n        this.elems.splice(index, 0, ...values);\n    }\n    /**\n     * Deletes `numDelete` list items starting at position `index`.\n     * if `numDelete` is not given, one item is deleted.\n     */\n    deleteAt(index, numDelete = 1) {\n        if (this[_constants__WEBPACK_IMPORTED_MODULE_0__.STATE]) {\n            throw new RangeError(\"object cannot be modified outside of a change block\");\n        }\n        this.elems.splice(index, numDelete);\n    }\n    map(callback) {\n        this.elems.map(callback);\n    }\n    lastIndexOf(searchElement, fromIndex) {\n        this.elems.lastIndexOf(searchElement, fromIndex);\n    }\n    concat(other) {\n        return new Text(this.elems.concat(other.elems));\n    }\n    every(test) {\n        return this.elems.every(test);\n    }\n    filter(test) {\n        return new Text(this.elems.filter(test));\n    }\n    find(test) {\n        return this.elems.find(test);\n    }\n    findIndex(test) {\n        return this.elems.findIndex(test);\n    }\n    forEach(f) {\n        this.elems.forEach(f);\n    }\n    includes(elem) {\n        return this.elems.includes(elem);\n    }\n    indexOf(elem) {\n        return this.elems.indexOf(elem);\n    }\n    join(sep) {\n        return this.elems.join(sep);\n    }\n    reduce(f) {\n        this.elems.reduce(f);\n    }\n    reduceRight(f) {\n        this.elems.reduceRight(f);\n    }\n    slice(start, end) {\n        new Text(this.elems.slice(start, end));\n    }\n    some(test) {\n        return this.elems.some(test);\n    }\n    toLocaleString() {\n        this.toString();\n    }\n}\n\n\n//# sourceURL=webpack://experiments/./node_modules/@automerge/automerge/dist/mjs/text.js?");

/***/ }),

/***/ "./node_modules/@automerge/automerge/dist/mjs/types.js":
/*!*************************************************************!*\
  !*** ./node_modules/@automerge/automerge/dist/mjs/types.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Counter: () => (/* reexport safe */ _counter__WEBPACK_IMPORTED_MODULE_1__.Counter),\n/* harmony export */   Float64: () => (/* reexport safe */ _numbers__WEBPACK_IMPORTED_MODULE_2__.Float64),\n/* harmony export */   Int: () => (/* reexport safe */ _numbers__WEBPACK_IMPORTED_MODULE_2__.Int),\n/* harmony export */   Text: () => (/* reexport safe */ _text__WEBPACK_IMPORTED_MODULE_0__.Text),\n/* harmony export */   Uint: () => (/* reexport safe */ _numbers__WEBPACK_IMPORTED_MODULE_2__.Uint)\n/* harmony export */ });\n/* harmony import */ var _text__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./text */ \"./node_modules/@automerge/automerge/dist/mjs/text.js\");\n/* harmony import */ var _counter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./counter */ \"./node_modules/@automerge/automerge/dist/mjs/counter.js\");\n/* harmony import */ var _numbers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./numbers */ \"./node_modules/@automerge/automerge/dist/mjs/numbers.js\");\n\n\n\n\n\n//# sourceURL=webpack://experiments/./node_modules/@automerge/automerge/dist/mjs/types.js?");

/***/ }),

/***/ "./node_modules/@automerge/automerge/dist/mjs/unstable.js":
/*!****************************************************************!*\
  !*** ./node_modules/@automerge/automerge/dist/mjs/unstable.js ***!
  \****************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Counter: () => (/* reexport safe */ _unstable_types__WEBPACK_IMPORTED_MODULE_0__.Counter),\n/* harmony export */   Float64: () => (/* reexport safe */ _unstable_types__WEBPACK_IMPORTED_MODULE_0__.Float64),\n/* harmony export */   Int: () => (/* reexport safe */ _unstable_types__WEBPACK_IMPORTED_MODULE_0__.Int),\n/* harmony export */   RawString: () => (/* reexport safe */ _raw_string__WEBPACK_IMPORTED_MODULE_3__.RawString),\n/* harmony export */   Uint: () => (/* reexport safe */ _unstable_types__WEBPACK_IMPORTED_MODULE_0__.Uint),\n/* harmony export */   applyChanges: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_2__.applyChanges),\n/* harmony export */   change: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_2__.change),\n/* harmony export */   clone: () => (/* binding */ clone),\n/* harmony export */   decodeChange: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_2__.decodeChange),\n/* harmony export */   decodeSyncMessage: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_2__.decodeSyncMessage),\n/* harmony export */   decodeSyncState: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_2__.decodeSyncState),\n/* harmony export */   dump: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_2__.dump),\n/* harmony export */   emptyChange: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_2__.emptyChange),\n/* harmony export */   encodeChange: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_2__.encodeChange),\n/* harmony export */   encodeSyncMessage: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_2__.encodeSyncMessage),\n/* harmony export */   encodeSyncState: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_2__.encodeSyncState),\n/* harmony export */   equals: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_2__.equals),\n/* harmony export */   free: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_2__.free),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   generateSyncMessage: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_2__.generateSyncMessage),\n/* harmony export */   getActorId: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_2__.getActorId),\n/* harmony export */   getAllChanges: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_2__.getAllChanges),\n/* harmony export */   getBackend: () => (/* binding */ getBackend),\n/* harmony export */   getChanges: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_2__.getChanges),\n/* harmony export */   getConflicts: () => (/* binding */ getConflicts),\n/* harmony export */   getHeads: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_2__.getHeads),\n/* harmony export */   getHistory: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_2__.getHistory),\n/* harmony export */   getLastLocalChange: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_2__.getLastLocalChange),\n/* harmony export */   getMissingDeps: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_2__.getMissingDeps),\n/* harmony export */   getObjectId: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_2__.getObjectId),\n/* harmony export */   init: () => (/* binding */ init),\n/* harmony export */   initSyncState: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_2__.initSyncState),\n/* harmony export */   isAutomerge: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_2__.isAutomerge),\n/* harmony export */   load: () => (/* binding */ load),\n/* harmony export */   loadIncremental: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_2__.loadIncremental),\n/* harmony export */   mark: () => (/* binding */ mark),\n/* harmony export */   marks: () => (/* binding */ marks),\n/* harmony export */   merge: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_2__.merge),\n/* harmony export */   receiveSyncMessage: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_2__.receiveSyncMessage),\n/* harmony export */   save: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_2__.save),\n/* harmony export */   splice: () => (/* binding */ splice),\n/* harmony export */   toJS: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_2__.toJS),\n/* harmony export */   unmark: () => (/* binding */ unmark),\n/* harmony export */   view: () => (/* reexport safe */ _stable__WEBPACK_IMPORTED_MODULE_2__.view)\n/* harmony export */ });\n/* harmony import */ var _unstable_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./unstable_types */ \"./node_modules/@automerge/automerge/dist/mjs/unstable_types.js\");\n/* harmony import */ var _conflicts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./conflicts */ \"./node_modules/@automerge/automerge/dist/mjs/conflicts.js\");\n/* harmony import */ var _stable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stable */ \"./node_modules/@automerge/automerge/dist/mjs/stable.js\");\n/* harmony import */ var _raw_string__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./raw_string */ \"./node_modules/@automerge/automerge/dist/mjs/raw_string.js\");\n/* harmony import */ var _internal_state__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./internal_state */ \"./node_modules/@automerge/automerge/dist/mjs/internal_state.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_stable__WEBPACK_IMPORTED_MODULE_2__]);\n_stable__WEBPACK_IMPORTED_MODULE_2__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n/**\n * # The unstable API\n *\n * This module contains new features we are working on which are either not yet\n * ready for a stable release and/or which will result in backwards incompatible\n * API changes. The API of this module may change in arbitrary ways between\n * point releases - we will always document what these changes are in the\n * [CHANGELOG](#changelog) below, but only depend on this module if you are prepared to deal\n * with frequent changes.\n *\n * ## Differences from stable\n *\n * In the stable API text objects are represented using the {@link Text} class.\n * This means you must decide up front whether your string data might need\n * concurrent merges in the future and if you change your mind you have to\n * figure out how to migrate your data. In the unstable API the `Text` class is\n * gone and all `string`s are represented using the text CRDT, allowing for\n * concurrent changes. Modifying a string is done using the {@link splice}\n * function. You can still access the old behaviour of strings which do not\n * support merging behaviour via the {@link RawString} class.\n *\n * This leads to the following differences from `stable`:\n *\n * * There is no `unstable.Text` class, all strings are text objects\n * * Reading strings in an `unstable` document is the same as reading any other\n *   javascript string\n * * To modify strings in an `unstable` document use {@link splice}\n * * The {@link AutomergeValue} type does not include the {@link Text}\n *   class but the  {@link RawString} class is included in the {@link ScalarValue}\n *   type\n *\n * ## CHANGELOG\n * * Introduce this module to expose the new API which has no `Text` class\n *\n *\n * @module\n */\n\n\n\n\n\n/** @hidden */\nconst getBackend = _stable__WEBPACK_IMPORTED_MODULE_2__.getBackend;\n\n/**\n * Create a new automerge document\n *\n * @typeParam T - The type of value contained in the document. This will be the\n *     type that is passed to the change closure in {@link change}\n * @param _opts - Either an actorId or an {@link InitOptions} (which may\n *     contain an actorId). If this is null the document will be initialised with a\n *     random actor ID\n */\nfunction init(_opts) {\n    const opts = importOpts(_opts);\n    opts.enableTextV2 = true;\n    return _stable__WEBPACK_IMPORTED_MODULE_2__.init(opts);\n}\n/**\n * Make a full writable copy of an automerge document\n *\n * @remarks\n * Unlike {@link view} this function makes a full copy of the memory backing\n * the document and can thus be passed to {@link change}. It also generates a\n * new actor ID so that changes made in the new document do not create duplicate\n * sequence numbers with respect to the old document. If you need control over\n * the actor ID which is generated you can pass the actor ID as the second\n * argument\n *\n * @typeParam T - The type of the value contained in the document\n * @param doc - The document to clone\n * @param _opts - Either an actor ID to use for the new doc or an {@link InitOptions}\n */\nfunction clone(doc, _opts) {\n    const opts = importOpts(_opts);\n    opts.enableTextV2 = true;\n    return _stable__WEBPACK_IMPORTED_MODULE_2__.clone(doc, opts);\n}\n/**\n * Create an automerge document from a POJO\n *\n * @param initialState - The initial state which will be copied into the document\n * @typeParam T - The type of the value passed to `from` _and_ the type the resulting document will contain\n * @typeParam actor - The actor ID of the resulting document, if this is null a random actor ID will be used\n *\n * @example\n * ```\n * const doc = automerge.from({\n *     tasks: [\n *         {description: \"feed dogs\", done: false}\n *     ]\n * })\n * ```\n */\nfunction from(initialState, _opts) {\n    const opts = importOpts(_opts);\n    opts.enableTextV2 = true;\n    return _stable__WEBPACK_IMPORTED_MODULE_2__.from(initialState, opts);\n}\n/**\n * Load an automerge document from a compressed document produce by {@link save}\n *\n * @typeParam T - The type of the value which is contained in the document.\n *                Note that no validation is done to make sure this type is in\n *                fact the type of the contained value so be a bit careful\n * @param data  - The compressed document\n * @param _opts - Either an actor ID or some {@link InitOptions}, if the actor\n *                ID is null a random actor ID will be created\n *\n * Note that `load` will throw an error if passed incomplete content (for\n * example if you are receiving content over the network and don't know if you\n * have the complete document yet). If you need to handle incomplete content use\n * {@link init} followed by {@link loadIncremental}.\n */\nfunction load(data, _opts) {\n    const opts = importOpts(_opts);\n    opts.enableTextV2 = true;\n    if (opts.patchCallback) {\n        return _stable__WEBPACK_IMPORTED_MODULE_2__.loadIncremental(_stable__WEBPACK_IMPORTED_MODULE_2__.init(opts), data);\n    }\n    else {\n        return _stable__WEBPACK_IMPORTED_MODULE_2__.load(data, opts);\n    }\n}\nfunction importOpts(_actor) {\n    if (typeof _actor === \"object\") {\n        return _actor;\n    }\n    else {\n        return { actor: _actor };\n    }\n}\nfunction splice(doc, prop, index, del, newText) {\n    if (!(0,_internal_state__WEBPACK_IMPORTED_MODULE_4__._is_proxy)(doc)) {\n        throw new RangeError(\"object cannot be modified outside of a change block\");\n    }\n    const state = (0,_internal_state__WEBPACK_IMPORTED_MODULE_4__._state)(doc, false);\n    const objectId = (0,_internal_state__WEBPACK_IMPORTED_MODULE_4__._obj)(doc);\n    if (!objectId) {\n        throw new RangeError(\"invalid object for splice\");\n    }\n    const value = `${objectId}/${prop}`;\n    try {\n        return state.handle.splice(value, index, del, newText);\n    }\n    catch (e) {\n        throw new RangeError(`Cannot splice: ${e}`);\n    }\n}\nfunction mark(doc, prop, range, name, value) {\n    if (!(0,_internal_state__WEBPACK_IMPORTED_MODULE_4__._is_proxy)(doc)) {\n        throw new RangeError(\"object cannot be modified outside of a change block\");\n    }\n    const state = (0,_internal_state__WEBPACK_IMPORTED_MODULE_4__._state)(doc, false);\n    const objectId = (0,_internal_state__WEBPACK_IMPORTED_MODULE_4__._obj)(doc);\n    if (!objectId) {\n        throw new RangeError(\"invalid object for mark\");\n    }\n    const obj = `${objectId}/${prop}`;\n    try {\n        return state.handle.mark(obj, range, name, value);\n    }\n    catch (e) {\n        throw new RangeError(`Cannot mark: ${e}`);\n    }\n}\nfunction unmark(doc, prop, range, name) {\n    if (!(0,_internal_state__WEBPACK_IMPORTED_MODULE_4__._is_proxy)(doc)) {\n        throw new RangeError(\"object cannot be modified outside of a change block\");\n    }\n    const state = (0,_internal_state__WEBPACK_IMPORTED_MODULE_4__._state)(doc, false);\n    const objectId = (0,_internal_state__WEBPACK_IMPORTED_MODULE_4__._obj)(doc);\n    if (!objectId) {\n        throw new RangeError(\"invalid object for unmark\");\n    }\n    const obj = `${objectId}/${prop}`;\n    try {\n        return state.handle.unmark(obj, range, name);\n    }\n    catch (e) {\n        throw new RangeError(`Cannot unmark: ${e}`);\n    }\n}\nfunction marks(doc, prop) {\n    const state = (0,_internal_state__WEBPACK_IMPORTED_MODULE_4__._state)(doc, false);\n    const objectId = (0,_internal_state__WEBPACK_IMPORTED_MODULE_4__._obj)(doc);\n    if (!objectId) {\n        throw new RangeError(\"invalid object for unmark\");\n    }\n    const obj = `${objectId}/${prop}`;\n    try {\n        return state.handle.marks(obj);\n    }\n    catch (e) {\n        throw new RangeError(`Cannot call marks(): ${e}`);\n    }\n}\n/**\n * Get the conflicts associated with a property\n *\n * The values of properties in a map in automerge can be conflicted if there\n * are concurrent \"put\" operations to the same key. Automerge chooses one value\n * arbitrarily (but deterministically, any two nodes who have the same set of\n * changes will choose the same value) from the set of conflicting values to\n * present as the value of the key.\n *\n * Sometimes you may want to examine these conflicts, in this case you can use\n * {@link getConflicts} to get the conflicts for the key.\n *\n * @example\n * ```\n * import * as automerge from \"@automerge/automerge\"\n *\n * type Profile = {\n *     pets: Array<{name: string, type: string}>\n * }\n *\n * let doc1 = automerge.init<Profile>(\"aaaa\")\n * doc1 = automerge.change(doc1, d => {\n *     d.pets = [{name: \"Lassie\", type: \"dog\"}]\n * })\n * let doc2 = automerge.init<Profile>(\"bbbb\")\n * doc2 = automerge.merge(doc2, automerge.clone(doc1))\n *\n * doc2 = automerge.change(doc2, d => {\n *     d.pets[0].name = \"Beethoven\"\n * })\n *\n * doc1 = automerge.change(doc1, d => {\n *     d.pets[0].name = \"Babe\"\n * })\n *\n * const doc3 = automerge.merge(doc1, doc2)\n *\n * // Note that here we pass `doc3.pets`, not `doc3`\n * let conflicts = automerge.getConflicts(doc3.pets[0], \"name\")\n *\n * // The two conflicting values are the keys of the conflicts object\n * assert.deepEqual(Object.values(conflicts), [\"Babe\", Beethoven\"])\n * ```\n */\nfunction getConflicts(doc, prop) {\n    const state = (0,_internal_state__WEBPACK_IMPORTED_MODULE_4__._state)(doc, false);\n    if (!state.textV2) {\n        throw new Error(\"use getConflicts for a stable document\");\n    }\n    const objectId = (0,_internal_state__WEBPACK_IMPORTED_MODULE_4__._obj)(doc);\n    if (objectId != null) {\n        return (0,_conflicts__WEBPACK_IMPORTED_MODULE_1__.unstableConflictAt)(state.handle, objectId, prop);\n    }\n    else {\n        return undefined;\n    }\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://experiments/./node_modules/@automerge/automerge/dist/mjs/unstable.js?");

/***/ }),

/***/ "./node_modules/@automerge/automerge/dist/mjs/unstable_types.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@automerge/automerge/dist/mjs/unstable_types.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Counter: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_0__.Counter),\n/* harmony export */   Float64: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_0__.Float64),\n/* harmony export */   Int: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_0__.Int),\n/* harmony export */   RawString: () => (/* reexport safe */ _raw_string__WEBPACK_IMPORTED_MODULE_1__.RawString),\n/* harmony export */   Uint: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_0__.Uint)\n/* harmony export */ });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"./node_modules/@automerge/automerge/dist/mjs/types.js\");\n/* harmony import */ var _raw_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./raw_string */ \"./node_modules/@automerge/automerge/dist/mjs/raw_string.js\");\n\n\n\n\n//# sourceURL=webpack://experiments/./node_modules/@automerge/automerge/dist/mjs/unstable_types.js?");

/***/ }),

/***/ "./node_modules/@automerge/automerge/dist/mjs/uuid.js":
/*!************************************************************!*\
  !*** ./node_modules/@automerge/automerge/dist/mjs/uuid.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   uuid: () => (/* binding */ uuid)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uuid */ \"./node_modules/uuid/dist/esm-browser/v4.js\");\n\nfunction defaultFactory() {\n    return (0,uuid__WEBPACK_IMPORTED_MODULE_0__[\"default\"])().replace(/-/g, \"\");\n}\nlet factory = defaultFactory;\nconst uuid = () => {\n    return factory();\n};\nuuid.setFactory = newFactory => {\n    factory = newFactory;\n};\nuuid.reset = () => {\n    factory = defaultFactory;\n};\n\n\n//# sourceURL=webpack://experiments/./node_modules/@automerge/automerge/dist/mjs/uuid.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/native.js":
/*!******************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/native.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  randomUUID\n});\n\n//# sourceURL=webpack://experiments/./node_modules/uuid/dist/esm-browser/native.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/regex.js":
/*!*****************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/regex.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);\n\n//# sourceURL=webpack://experiments/./node_modules/uuid/dist/esm-browser/regex.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/rng.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/rng.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ rng)\n/* harmony export */ });\n// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nlet getRandomValues;\nconst rnds8 = new Uint8Array(16);\nfunction rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}\n\n//# sourceURL=webpack://experiments/./node_modules/uuid/dist/esm-browser/rng.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/stringify.js":
/*!*********************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/stringify.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   unsafeStringify: () => (/* binding */ unsafeStringify)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"./node_modules/uuid/dist/esm-browser/validate.js\");\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nfunction unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();\n}\n\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stringify);\n\n//# sourceURL=webpack://experiments/./node_modules/uuid/dist/esm-browser/stringify.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/v4.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v4.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _native_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./native.js */ \"./node_modules/uuid/dist/esm-browser/native.js\");\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rng.js */ \"./node_modules/uuid/dist/esm-browser/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stringify.js */ \"./node_modules/uuid/dist/esm-browser/stringify.js\");\n\n\n\n\nfunction v4(options, buf, offset) {\n  if (_native_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomUUID && !buf && !options) {\n    return _native_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomUUID();\n  }\n\n  options = options || {};\n  const rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_2__.unsafeStringify)(rnds);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v4);\n\n//# sourceURL=webpack://experiments/./node_modules/uuid/dist/esm-browser/v4.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/validate.js":
/*!********************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/validate.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex.js */ \"./node_modules/uuid/dist/esm-browser/regex.js\");\n\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && _regex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].test(uuid);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validate);\n\n//# sourceURL=webpack://experiments/./node_modules/uuid/dist/esm-browser/validate.js?");

/***/ }),

/***/ "./public/js/initializeEditor.js":
/*!***************************************!*\
  !*** ./public/js/initializeEditor.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   editor: () => (/* binding */ editor),\n/* harmony export */   initializeEditor: () => (/* binding */ initializeEditor),\n/* harmony export */   tiny: () => (/* binding */ tiny)\n/* harmony export */ });\nlet editor, tiny;\r\n\r\nfunction initializeEditor() {\r\n  tiny = tinymce.init({\r\n    height: \"100vh\",\r\n    selector: \"div#editor\",\r\n    plugins: [\r\n      \"advlist\", \"anchor\", \"autolink\", \"charmap\", \"code\", \"codesample\", \"fullscreen\",\r\n      \"help\", \"image\", \"insertdatetime\", \"link\", \"lists\", \"media\",\r\n      \"preview\", \"searchreplace\", \"table\", \"visualblocks\", \"accordion\", \"advlist\", \"searchreplace\", \"pagebreak\"\r\n    ],\r\n    toolbar: \"undo redo |\" +\r\n      \"fontfamily fontsize forecolor backcolor| link image accordion |\" +\r\n      \"bold italic underline strikethrough subscript superscript pagebreak |\" +\r\n      \" align | outdent indent | bullist numlist |\" +\r\n      \" codesample searchreplace blockquote lineheight\",\r\n    statusbar: false,\r\n    setup: function (editorSpace) {\r\n      editor = editorSpace;\r\n    },\r\n    content_style:`\r\n                body {\r\n                    background: #fff;\r\n                }\r\n\r\n                @media (min-width: 840px) {\r\n                    html {\r\n                        background: #eceef4;\r\n                        min-height: 100%;\r\n                        padding: 0 .5rem\r\n                    }\r\n\r\n                    body {\r\n                        background-color: #fff;\r\n                        box-shadow: 0 0 4px rgba(0, 0, 0, .15);\r\n                        box-sizing: border-box;\r\n                        margin: 1rem auto;\r\n                        max-width: 820px;\r\n                        min-height: calc(100vh - 1rem);\r\n                        padding: 1.5rem 2.5rem 2.5rem;\r\n                        height: 842px;\r\n                    }\r\n                }\r\n             `\r\n  })\r\n}\r\n\r\n\n\n//# sourceURL=webpack://experiments/./public/js/initializeEditor.js?");

/***/ }),

/***/ "./public/js/main.js":
/*!***************************!*\
  !*** ./public/js/main.js ***!
  \***************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _initializeEditor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./initializeEditor */ \"./public/js/initializeEditor.js\");\n/* harmony import */ var _automerge_automerge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @automerge/automerge */ \"./node_modules/@automerge/automerge/dist/mjs/index.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_automerge_automerge__WEBPACK_IMPORTED_MODULE_1__]);\n_automerge_automerge__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\r\n\r\n// import { loadDoc } from './domHandler';\r\n\r\n\r\n(0,_initializeEditor__WEBPACK_IMPORTED_MODULE_0__.initializeEditor)() // tinymce.init()\r\nconst socket = io()\r\n\r\n_initializeEditor__WEBPACK_IMPORTED_MODULE_0__.editor.on('init', () => {\r\n    _initializeEditor__WEBPACK_IMPORTED_MODULE_0__.editor.setContent(\"<p id='e23frw23'>Start typing here...</p>\")\r\n})\r\n \r\n\r\n_initializeEditor__WEBPACK_IMPORTED_MODULE_0__.editor.on('change', () => {\r\n    socket.emit('doc-updated', _initializeEditor__WEBPACK_IMPORTED_MODULE_0__.editor.getContent())\r\n})\r\n\r\n_initializeEditor__WEBPACK_IMPORTED_MODULE_0__.editor.on('input', () => {\r\n    socket.emit('doc-updated', _initializeEditor__WEBPACK_IMPORTED_MODULE_0__.editor.getContent())\r\n})\r\n\r\nsocket.on('update-doc', (msg) => {\r\n    _initializeEditor__WEBPACK_IMPORTED_MODULE_0__.editor.setContent(msg)\r\n})\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://experiments/./public/js/main.js?");

/***/ }),

/***/ "./node_modules/@automerge/automerge-wasm/bundler/automerge_wasm_bg.wasm":
/*!*******************************************************************************!*\
  !*** ./node_modules/@automerge/automerge-wasm/bundler/automerge_wasm_bg.wasm ***!
  \*******************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* harmony import */ var WEBPACK_IMPORTED_MODULE_0 = __webpack_require__(/*! ./automerge_wasm_bg.js */ \"./node_modules/@automerge/automerge-wasm/bundler/automerge_wasm_bg.js\");\nmodule.exports = __webpack_require__.v(exports, module.id, \"aa485d2b3bd182b89240\", {\n\t\"./automerge_wasm_bg.js\": {\n\t\t\"__wbindgen_object_drop_ref\": WEBPACK_IMPORTED_MODULE_0.__wbindgen_object_drop_ref,\n\t\t\"__wbindgen_string_new\": WEBPACK_IMPORTED_MODULE_0.__wbindgen_string_new,\n\t\t\"__wbindgen_is_null\": WEBPACK_IMPORTED_MODULE_0.__wbindgen_is_null,\n\t\t\"__wbindgen_error_new\": WEBPACK_IMPORTED_MODULE_0.__wbindgen_error_new,\n\t\t\"__wbindgen_string_get\": WEBPACK_IMPORTED_MODULE_0.__wbindgen_string_get,\n\t\t\"__wbindgen_object_clone_ref\": WEBPACK_IMPORTED_MODULE_0.__wbindgen_object_clone_ref,\n\t\t\"__wbindgen_number_get\": WEBPACK_IMPORTED_MODULE_0.__wbindgen_number_get,\n\t\t\"__wbindgen_is_undefined\": WEBPACK_IMPORTED_MODULE_0.__wbindgen_is_undefined,\n\t\t\"__wbindgen_boolean_get\": WEBPACK_IMPORTED_MODULE_0.__wbindgen_boolean_get,\n\t\t\"__wbindgen_number_new\": WEBPACK_IMPORTED_MODULE_0.__wbindgen_number_new,\n\t\t\"__wbindgen_is_function\": WEBPACK_IMPORTED_MODULE_0.__wbindgen_is_function,\n\t\t\"__wbindgen_is_string\": WEBPACK_IMPORTED_MODULE_0.__wbindgen_is_string,\n\t\t\"__wbindgen_json_serialize\": WEBPACK_IMPORTED_MODULE_0.__wbindgen_json_serialize,\n\t\t\"__wbg_new_abda76e883ba8a5f\": WEBPACK_IMPORTED_MODULE_0.__wbg_new_abda76e883ba8a5f,\n\t\t\"__wbg_stack_658279fe44541cf6\": WEBPACK_IMPORTED_MODULE_0.__wbg_stack_658279fe44541cf6,\n\t\t\"__wbg_error_f851667af71bcfc6\": WEBPACK_IMPORTED_MODULE_0.__wbg_error_f851667af71bcfc6,\n\t\t\"__wbindgen_is_object\": WEBPACK_IMPORTED_MODULE_0.__wbindgen_is_object,\n\t\t\"__wbindgen_jsval_loose_eq\": WEBPACK_IMPORTED_MODULE_0.__wbindgen_jsval_loose_eq,\n\t\t\"__wbg_String_91fba7ded13ba54c\": WEBPACK_IMPORTED_MODULE_0.__wbg_String_91fba7ded13ba54c,\n\t\t\"__wbindgen_bigint_from_i64\": WEBPACK_IMPORTED_MODULE_0.__wbindgen_bigint_from_i64,\n\t\t\"__wbindgen_bigint_from_u64\": WEBPACK_IMPORTED_MODULE_0.__wbindgen_bigint_from_u64,\n\t\t\"__wbg_set_20cbc34131e76824\": WEBPACK_IMPORTED_MODULE_0.__wbg_set_20cbc34131e76824,\n\t\t\"__wbg_getRandomValues_3774744e221a22ad\": WEBPACK_IMPORTED_MODULE_0.__wbg_getRandomValues_3774744e221a22ad,\n\t\t\"__wbg_randomFillSync_e950366c42764a07\": WEBPACK_IMPORTED_MODULE_0.__wbg_randomFillSync_e950366c42764a07,\n\t\t\"__wbg_crypto_70a96de3b6b73dac\": WEBPACK_IMPORTED_MODULE_0.__wbg_crypto_70a96de3b6b73dac,\n\t\t\"__wbg_process_dd1577445152112e\": WEBPACK_IMPORTED_MODULE_0.__wbg_process_dd1577445152112e,\n\t\t\"__wbg_versions_58036bec3add9e6f\": WEBPACK_IMPORTED_MODULE_0.__wbg_versions_58036bec3add9e6f,\n\t\t\"__wbg_node_6a9d28205ed5b0d8\": WEBPACK_IMPORTED_MODULE_0.__wbg_node_6a9d28205ed5b0d8,\n\t\t\"__wbg_msCrypto_adbc770ec9eca9c7\": WEBPACK_IMPORTED_MODULE_0.__wbg_msCrypto_adbc770ec9eca9c7,\n\t\t\"__wbg_require_f05d779769764e82\": WEBPACK_IMPORTED_MODULE_0.__wbg_require_f05d779769764e82,\n\t\t\"__wbg_log_7bb108d119bafbc1\": WEBPACK_IMPORTED_MODULE_0.__wbg_log_7bb108d119bafbc1,\n\t\t\"__wbg_log_d047cf0648d2678e\": WEBPACK_IMPORTED_MODULE_0.__wbg_log_d047cf0648d2678e,\n\t\t\"__wbg_get_27fe3dac1c4d0224\": WEBPACK_IMPORTED_MODULE_0.__wbg_get_27fe3dac1c4d0224,\n\t\t\"__wbg_length_e498fbc24f9c1d4f\": WEBPACK_IMPORTED_MODULE_0.__wbg_length_e498fbc24f9c1d4f,\n\t\t\"__wbg_new_b525de17f44a8943\": WEBPACK_IMPORTED_MODULE_0.__wbg_new_b525de17f44a8943,\n\t\t\"__wbg_newnoargs_2b8b6bd7753c76ba\": WEBPACK_IMPORTED_MODULE_0.__wbg_newnoargs_2b8b6bd7753c76ba,\n\t\t\"__wbg_next_b7d530c04fd8b217\": WEBPACK_IMPORTED_MODULE_0.__wbg_next_b7d530c04fd8b217,\n\t\t\"__wbg_next_88560ec06a094dea\": WEBPACK_IMPORTED_MODULE_0.__wbg_next_88560ec06a094dea,\n\t\t\"__wbg_done_1ebec03bbd919843\": WEBPACK_IMPORTED_MODULE_0.__wbg_done_1ebec03bbd919843,\n\t\t\"__wbg_value_6ac8da5cc5b3efda\": WEBPACK_IMPORTED_MODULE_0.__wbg_value_6ac8da5cc5b3efda,\n\t\t\"__wbg_iterator_55f114446221aa5a\": WEBPACK_IMPORTED_MODULE_0.__wbg_iterator_55f114446221aa5a,\n\t\t\"__wbg_get_baf4855f9a986186\": WEBPACK_IMPORTED_MODULE_0.__wbg_get_baf4855f9a986186,\n\t\t\"__wbg_call_95d1ea488d03e4e8\": WEBPACK_IMPORTED_MODULE_0.__wbg_call_95d1ea488d03e4e8,\n\t\t\"__wbg_new_f9876326328f45ed\": WEBPACK_IMPORTED_MODULE_0.__wbg_new_f9876326328f45ed,\n\t\t\"__wbg_length_ea0846e494e3b16e\": WEBPACK_IMPORTED_MODULE_0.__wbg_length_ea0846e494e3b16e,\n\t\t\"__wbg_set_17224bc548dd1d7b\": WEBPACK_IMPORTED_MODULE_0.__wbg_set_17224bc548dd1d7b,\n\t\t\"__wbg_from_67ca20fa722467e6\": WEBPACK_IMPORTED_MODULE_0.__wbg_from_67ca20fa722467e6,\n\t\t\"__wbg_isArray_39d28997bf6b96b4\": WEBPACK_IMPORTED_MODULE_0.__wbg_isArray_39d28997bf6b96b4,\n\t\t\"__wbg_push_49c286f04dd3bf59\": WEBPACK_IMPORTED_MODULE_0.__wbg_push_49c286f04dd3bf59,\n\t\t\"__wbg_unshift_06a94bcbcb492eb3\": WEBPACK_IMPORTED_MODULE_0.__wbg_unshift_06a94bcbcb492eb3,\n\t\t\"__wbg_instanceof_ArrayBuffer_a69f02ee4c4f5065\": WEBPACK_IMPORTED_MODULE_0.__wbg_instanceof_ArrayBuffer_a69f02ee4c4f5065,\n\t\t\"__wbg_new_15d3966e9981a196\": WEBPACK_IMPORTED_MODULE_0.__wbg_new_15d3966e9981a196,\n\t\t\"__wbg_call_9495de66fdbe016b\": WEBPACK_IMPORTED_MODULE_0.__wbg_call_9495de66fdbe016b,\n\t\t\"__wbg_call_96878afb7a8201ca\": WEBPACK_IMPORTED_MODULE_0.__wbg_call_96878afb7a8201ca,\n\t\t\"__wbg_instanceof_Date_e353425d719aa266\": WEBPACK_IMPORTED_MODULE_0.__wbg_instanceof_Date_e353425d719aa266,\n\t\t\"__wbg_getTime_7c59072d1651a3cf\": WEBPACK_IMPORTED_MODULE_0.__wbg_getTime_7c59072d1651a3cf,\n\t\t\"__wbg_new_f127e324c1313064\": WEBPACK_IMPORTED_MODULE_0.__wbg_new_f127e324c1313064,\n\t\t\"__wbg_instanceof_Object_f5a826c4da0d4a94\": WEBPACK_IMPORTED_MODULE_0.__wbg_instanceof_Object_f5a826c4da0d4a94,\n\t\t\"__wbg_assign_b0b6530984f36574\": WEBPACK_IMPORTED_MODULE_0.__wbg_assign_b0b6530984f36574,\n\t\t\"__wbg_defineProperty_4926f24c724d5310\": WEBPACK_IMPORTED_MODULE_0.__wbg_defineProperty_4926f24c724d5310,\n\t\t\"__wbg_entries_4e1315b774245952\": WEBPACK_IMPORTED_MODULE_0.__wbg_entries_4e1315b774245952,\n\t\t\"__wbg_freeze_4dcdbf0b5d9b50f4\": WEBPACK_IMPORTED_MODULE_0.__wbg_freeze_4dcdbf0b5d9b50f4,\n\t\t\"__wbg_keys_60443f4f867207f9\": WEBPACK_IMPORTED_MODULE_0.__wbg_keys_60443f4f867207f9,\n\t\t\"__wbg_values_7444c4c2ccefdc9b\": WEBPACK_IMPORTED_MODULE_0.__wbg_values_7444c4c2ccefdc9b,\n\t\t\"__wbg_apply_5435e78b95a524a6\": WEBPACK_IMPORTED_MODULE_0.__wbg_apply_5435e78b95a524a6,\n\t\t\"__wbg_deleteProperty_31090878b92a7c0e\": WEBPACK_IMPORTED_MODULE_0.__wbg_deleteProperty_31090878b92a7c0e,\n\t\t\"__wbg_ownKeys_9efe69be404540aa\": WEBPACK_IMPORTED_MODULE_0.__wbg_ownKeys_9efe69be404540aa,\n\t\t\"__wbg_set_6aa458a4ebdb65cb\": WEBPACK_IMPORTED_MODULE_0.__wbg_set_6aa458a4ebdb65cb,\n\t\t\"__wbg_buffer_cf65c07de34b9a08\": WEBPACK_IMPORTED_MODULE_0.__wbg_buffer_cf65c07de34b9a08,\n\t\t\"__wbg_concat_040af6c9ba38dd98\": WEBPACK_IMPORTED_MODULE_0.__wbg_concat_040af6c9ba38dd98,\n\t\t\"__wbg_slice_47202b1d012cdc55\": WEBPACK_IMPORTED_MODULE_0.__wbg_slice_47202b1d012cdc55,\n\t\t\"__wbg_for_9a885d0d6d415e40\": WEBPACK_IMPORTED_MODULE_0.__wbg_for_9a885d0d6d415e40,\n\t\t\"__wbg_toString_7a3e0cd68ea2a337\": WEBPACK_IMPORTED_MODULE_0.__wbg_toString_7a3e0cd68ea2a337,\n\t\t\"__wbg_self_e7c1f827057f6584\": WEBPACK_IMPORTED_MODULE_0.__wbg_self_e7c1f827057f6584,\n\t\t\"__wbg_window_a09ec664e14b1b81\": WEBPACK_IMPORTED_MODULE_0.__wbg_window_a09ec664e14b1b81,\n\t\t\"__wbg_globalThis_87cbb8506fecf3a9\": WEBPACK_IMPORTED_MODULE_0.__wbg_globalThis_87cbb8506fecf3a9,\n\t\t\"__wbg_global_c85a9259e621f3db\": WEBPACK_IMPORTED_MODULE_0.__wbg_global_c85a9259e621f3db,\n\t\t\"__wbg_newwithbyteoffsetandlength_9fb2f11355ecadf5\": WEBPACK_IMPORTED_MODULE_0.__wbg_newwithbyteoffsetandlength_9fb2f11355ecadf5,\n\t\t\"__wbg_new_537b7341ce90bb31\": WEBPACK_IMPORTED_MODULE_0.__wbg_new_537b7341ce90bb31,\n\t\t\"__wbg_set_17499e8aa4003ebd\": WEBPACK_IMPORTED_MODULE_0.__wbg_set_17499e8aa4003ebd,\n\t\t\"__wbg_length_27a2afe8ab42b09f\": WEBPACK_IMPORTED_MODULE_0.__wbg_length_27a2afe8ab42b09f,\n\t\t\"__wbg_instanceof_Uint8Array_01cebe79ca606cca\": WEBPACK_IMPORTED_MODULE_0.__wbg_instanceof_Uint8Array_01cebe79ca606cca,\n\t\t\"__wbg_newwithlength_b56c882b57805732\": WEBPACK_IMPORTED_MODULE_0.__wbg_newwithlength_b56c882b57805732,\n\t\t\"__wbg_subarray_7526649b91a252a6\": WEBPACK_IMPORTED_MODULE_0.__wbg_subarray_7526649b91a252a6,\n\t\t\"__wbindgen_debug_string\": WEBPACK_IMPORTED_MODULE_0.__wbindgen_debug_string,\n\t\t\"__wbindgen_throw\": WEBPACK_IMPORTED_MODULE_0.__wbindgen_throw,\n\t\t\"__wbindgen_memory\": WEBPACK_IMPORTED_MODULE_0.__wbindgen_memory\n\t}\n});\n\n//# sourceURL=webpack://experiments/./node_modules/@automerge/automerge-wasm/bundler/automerge_wasm_bg.wasm?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/async module */
/******/ 	(() => {
/******/ 		var webpackQueues = typeof Symbol === "function" ? Symbol("webpack queues") : "__webpack_queues__";
/******/ 		var webpackExports = typeof Symbol === "function" ? Symbol("webpack exports") : "__webpack_exports__";
/******/ 		var webpackError = typeof Symbol === "function" ? Symbol("webpack error") : "__webpack_error__";
/******/ 		var resolveQueue = (queue) => {
/******/ 			if(queue && queue.d < 1) {
/******/ 				queue.d = 1;
/******/ 				queue.forEach((fn) => (fn.r--));
/******/ 				queue.forEach((fn) => (fn.r-- ? fn.r++ : fn()));
/******/ 			}
/******/ 		}
/******/ 		var wrapDeps = (deps) => (deps.map((dep) => {
/******/ 			if(dep !== null && typeof dep === "object") {
/******/ 				if(dep[webpackQueues]) return dep;
/******/ 				if(dep.then) {
/******/ 					var queue = [];
/******/ 					queue.d = 0;
/******/ 					dep.then((r) => {
/******/ 						obj[webpackExports] = r;
/******/ 						resolveQueue(queue);
/******/ 					}, (e) => {
/******/ 						obj[webpackError] = e;
/******/ 						resolveQueue(queue);
/******/ 					});
/******/ 					var obj = {};
/******/ 					obj[webpackQueues] = (fn) => (fn(queue));
/******/ 					return obj;
/******/ 				}
/******/ 			}
/******/ 			var ret = {};
/******/ 			ret[webpackQueues] = x => {};
/******/ 			ret[webpackExports] = dep;
/******/ 			return ret;
/******/ 		}));
/******/ 		__webpack_require__.a = (module, body, hasAwait) => {
/******/ 			var queue;
/******/ 			hasAwait && ((queue = []).d = -1);
/******/ 			var depQueues = new Set();
/******/ 			var exports = module.exports;
/******/ 			var currentDeps;
/******/ 			var outerResolve;
/******/ 			var reject;
/******/ 			var promise = new Promise((resolve, rej) => {
/******/ 				reject = rej;
/******/ 				outerResolve = resolve;
/******/ 			});
/******/ 			promise[webpackExports] = exports;
/******/ 			promise[webpackQueues] = (fn) => (queue && fn(queue), depQueues.forEach(fn), promise["catch"](x => {}));
/******/ 			module.exports = promise;
/******/ 			body((deps) => {
/******/ 				currentDeps = wrapDeps(deps);
/******/ 				var fn;
/******/ 				var getResult = () => (currentDeps.map((d) => {
/******/ 					if(d[webpackError]) throw d[webpackError];
/******/ 					return d[webpackExports];
/******/ 				}))
/******/ 				var promise = new Promise((resolve) => {
/******/ 					fn = () => (resolve(getResult));
/******/ 					fn.r = 0;
/******/ 					var fnQueue = (q) => (q !== queue && !depQueues.has(q) && (depQueues.add(q), q && !q.d && (fn.r++, q.push(fn))));
/******/ 					currentDeps.map((dep) => (dep[webpackQueues](fnQueue)));
/******/ 				});
/******/ 				return fn.r ? promise : getResult();
/******/ 			}, (err) => ((err ? reject(promise[webpackError] = err) : outerResolve(exports)), resolveQueue(queue)));
/******/ 			queue && queue.d < 0 && (queue.d = 0);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/harmony module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.hmd = (module) => {
/******/ 			module = Object.create(module);
/******/ 			if (!module.children) module.children = [];
/******/ 			Object.defineProperty(module, 'exports', {
/******/ 				enumerable: true,
/******/ 				set: () => {
/******/ 					throw new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);
/******/ 				}
/******/ 			});
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/wasm loading */
/******/ 	(() => {
/******/ 		__webpack_require__.v = (exports, wasmModuleId, wasmModuleHash, importsObj) => {
/******/ 			var req = fetch(__webpack_require__.p + "" + wasmModuleHash + ".module.wasm");
/******/ 			if (typeof WebAssembly.instantiateStreaming === 'function') {
/******/ 				return WebAssembly.instantiateStreaming(req, importsObj)
/******/ 					.then((res) => (Object.assign(exports, res.instance.exports)));
/******/ 			}
/******/ 			return req
/******/ 				.then((x) => (x.arrayBuffer()))
/******/ 				.then((bytes) => (WebAssembly.instantiate(bytes, importsObj)))
/******/ 				.then((res) => (Object.assign(exports, res.instance.exports)));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && !scriptUrl) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./public/js/main.js");
/******/ 	
/******/ })()
;